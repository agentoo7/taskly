# Story 3.1: GitHub Repository Connection

## Status
Draft

---

## Story

**As a** workspace admin,
**I want** to connect GitHub repositories to my workspace,
**so that** I can link cards to branches and pull requests.

---

## Acceptance Criteria

1. Workspace settings displays "Connected Repositories" section with "+ Connect Repository" button (admin only)
2. Clicking button opens GitHub repository selector showing all repos user has access to (using OAuth token)
3. Repository list paginated (30 per page), searchable by name, filterable by owner (personal/organization)
4. Selecting repository creates `GitRepository` record and displays in connected repos list
5. Connected repository shows: repo name, owner, default branch, last synced timestamp, "Disconnect" button
6. Disconnecting repository requires confirmation: "Disconnect [repo]? Linked cards will lose branch/PR associations."
7. Disconnecting soft-deletes repository (sets `is_active = false`), preserves PR data for history
8. Board settings allows selecting default repository from connected repos for one-click branch creation
9. Multiple boards can share same default repository
10. Repository connection verifies user has admin/push access via GitHub API
11. Webhook automatically created on repository when connected (listens to PR events, push events)
12. Webhook secret stored securely, used to validate incoming webhook payloads

---

## Tasks / Subtasks

- [ ] **Task 1: Update GitRepository model** (AC: 4, 5, 7)
  - [ ] Verify `backend/app/models/git_repository.py` exists (created in Story 1.3)
  - [ ] Add fields: `webhook_id` (GitHub webhook ID), `webhook_secret` (encrypted)
  - [ ] Ensure `is_active` boolean for soft delete
  - [ ] Add `last_synced_at` timestamp field
  - [ ] Create migration if schema changes needed

- [ ] **Task 2: Create repository connection API endpoints** (AC: 2, 4, 5, 6, 7)
  - [ ] Implement `GET /workspaces/{id}/repositories/available` - fetch user's GitHub repos
  - [ ] Implement `POST /workspaces/{id}/repositories` - connect repository to workspace
  - [ ] Implement `GET /workspaces/{id}/repositories` - list connected repositories
  - [ ] Implement `DELETE /workspaces/{id}/repositories/{repo_id}` - disconnect repository
  - [ ] Add permission check: user must be workspace admin
  - [ ] Validate user has push access to repository via GitHub API

- [ ] **Task 3: Create repository service layer** (AC: 4, 10, 11, 12)
  - [ ] Create `backend/app/services/repository_service.py`
  - [ ] Implement `fetch_user_repositories(access_token)` - calls GitHub API
  - [ ] Implement `connect_repository(workspace_id, github_repo_data, user)` - creates GitRepository record
  - [ ] Implement `create_webhook(repo_full_name, access_token)` - creates GitHub webhook
  - [ ] Implement `disconnect_repository(repo_id)` - soft deletes, removes webhook
  - [ ] Generate secure random webhook secret (32 bytes)
  - [ ] Encrypt webhook secret before storing in database

- [ ] **Task 4: Integrate with GitHub API for repository listing** (AC: 2, 3, 10)
  - [ ] Use PyGithub library or httpx to call `GET /user/repos`
  - [ ] Support pagination: accept page number, return 30 repos per page
  - [ ] Filter repos by permissions: user must have `admin` or `push` access
  - [ ] Return repo data: id, name, owner, full_name, default_branch, permissions
  - [ ] Cache user's repositories in Redis for 5 minutes (reduce API calls)
  - [ ] Handle GitHub API rate limits gracefully (show error if limit exceeded)

- [ ] **Task 5: Implement webhook creation via GitHub API** (AC: 11, 12)
  - [ ] Call GitHub API `POST /repos/{owner}/{repo}/hooks`
  - [ ] Webhook config: url = `https://taskly.app/api/webhooks/github`, content_type = `json`
  - [ ] Subscribe to events: `pull_request`, `pull_request_review`, `push`, `check_suite`
  - [ ] Set webhook secret in config (used for HMAC signature validation)
  - [ ] Store returned webhook ID in GitRepository record
  - [ ] Handle errors: repo already has webhook, insufficient permissions

- [ ] **Task 6: Create repository selector component** (AC: 1, 2, 3, 4)
  - [ ] Create `frontend/src/components/workspace/repository-selector.tsx`
  - [ ] Fetch available repos: `GET /workspaces/{id}/repositories/available`
  - [ ] Display in modal with searchable list
  - [ ] Search filters repos by name (client-side)
  - [ ] Filter by owner: dropdown showing personal account + organizations
  - [ ] Pagination: show 30 repos, "Load More" button for next page
  - [ ] Each repo shows: avatar, full_name, default_branch, access level badge
  - [ ] On select, call `POST /workspaces/{id}/repositories` with github_repo_id

- [ ] **Task 7: Update workspace settings with connected repos section** (AC: 1, 5, 6, 7)
  - [ ] Update `frontend/src/app/(dashboard)/workspaces/[workspaceId]/settings/page.tsx`
  - [ ] Add "Connected Repositories" section
  - [ ] Display list of connected repos with details
  - [ ] Show "+ Connect Repository" button (admin only)
  - [ ] Each repo shows: icon, owner/name, default branch, last synced, "Disconnect" button
  - [ ] Disconnect confirmation: modal with repo name input
  - [ ] On disconnect, call `DELETE /workspaces/{id}/repositories/{repo_id}`

- [ ] **Task 8: Add default repository selector to board settings** (AC: 8, 9)
  - [ ] Update `frontend/src/app/(dashboard)/workspaces/[workspaceId]/boards/[boardId]/settings/page.tsx`
  - [ ] Add "Default Repository" dropdown showing connected workspace repos
  - [ ] Allow selection or "None" option
  - [ ] Save to `boards.default_repository_id` field (update Board model if needed)
  - [ ] Display current default repo in board header (optional)
  - [ ] Used for one-click branch creation in Story 3.2

- [ ] **Task 9: Add webhook secret encryption** (AC: 12)
  - [ ] Update `backend/app/core/security.py` with encryption utilities
  - [ ] Use Fernet (symmetric encryption) from cryptography library
  - [ ] Load encryption key from environment variable `WEBHOOK_ENCRYPTION_KEY`
  - [ ] Implement `encrypt_webhook_secret(secret)` and `decrypt_webhook_secret(encrypted)`
  - [ ] Store encrypted secret in database, decrypt when validating webhooks
  - [ ] Generate encryption key: `python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"`

- [ ] **Task 10: Handle webhook deletion on repository disconnect** (AC: 6, 7)
  - [ ] When disconnecting repository, call GitHub API `DELETE /repos/{owner}/{repo}/hooks/{hook_id}`
  - [ ] Use stored `webhook_id` from GitRepository record
  - [ ] Handle errors gracefully: webhook already deleted, API failure
  - [ ] Soft delete GitRepository (set `is_active = false`), preserve PR data
  - [ ] Clear `webhook_id` and `webhook_secret` fields after deletion

- [ ] **Task 11: Add repository sync status indicator** (AC: 5)
  - [ ] Display "Last synced" timestamp in connected repos list
  - [ ] Update `last_synced_at` field when processing webhooks
  - [ ] Show sync status: "Synced X minutes ago" using date-fns
  - [ ] Add manual "Sync Now" button (fetches latest PRs from GitHub)
  - [ ] Implement `POST /workspaces/{id}/repositories/{repo_id}/sync` endpoint
  - [ ] Sync fetches open PRs from GitHub and updates database

- [ ] **Task 12: Write tests for repository connection** (AC: 1-12)
  - [ ] Unit test: Webhook secret encryption/decryption
  - [ ] Unit test: Repository service connects repo and creates webhook
  - [ ] Integration test: Connect repository API endpoint
  - [ ] Integration test: Disconnect repository soft deletes and removes webhook
  - [ ] Integration test: Fetch available repositories from GitHub
  - [ ] Component test: Repository selector displays and filters repos
  - [ ] E2E test: Full repository connection workflow

---

## Dev Notes

### GitRepository Model

```python
# backend/app/models/git_repository.py
from sqlalchemy import Column, String, Integer, Boolean, DateTime, ForeignKey, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
from app.core.database import Base

class GitRepository(Base):
    __tablename__ = "git_repositories"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    workspace_id = Column(UUID(as_uuid=True), ForeignKey("workspaces.id", ondelete="CASCADE"), nullable=False)
    github_repo_id = Column(Integer, unique=True, nullable=False)
    owner = Column(String(100), nullable=False)
    name = Column(String(100), nullable=False)
    full_name = Column(String(255), nullable=False)  # owner/repo
    default_branch = Column(String(100), default="main")
    webhook_id = Column(Integer)  # GitHub webhook ID
    webhook_secret = Column(String(500))  # Encrypted
    is_active = Column(Boolean, default=True)
    connected_at = Column(DateTime(timezone=True), server_default=func.now())
    last_synced_at = Column(DateTime(timezone=True))
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    workspace = relationship("Workspace")
    pull_requests = relationship("PullRequest", back_populates="repository")
```

### Repository Service Implementation

```python
# backend/app/services/repository_service.py
from github import Github
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.git_repository import GitRepository
from app.core.security import encrypt_webhook_secret, decrypt_webhook_secret
import secrets
import os

WEBHOOK_URL = os.getenv("WEBHOOK_URL", "https://taskly.app/api/webhooks/github")

class RepositoryService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def fetch_user_repositories(self, access_token: str, page: int = 1) -> list:
        """Fetch user's GitHub repositories with push access."""
        g = Github(access_token)
        repos = g.get_user().get_repos(
            type='all',
            sort='updated',
            direction='desc'
        )

        # Filter repos with push access
        accessible_repos = []
        for repo in repos:
            if repo.permissions.admin or repo.permissions.push:
                accessible_repos.append({
                    'id': repo.id,
                    'name': repo.name,
                    'owner': repo.owner.login,
                    'full_name': repo.full_name,
                    'default_branch': repo.default_branch,
                    'avatar_url': repo.owner.avatar_url,
                })

        # Paginate
        start = (page - 1) * 30
        end = start + 30
        return accessible_repos[start:end]

    async def connect_repository(
        self,
        workspace_id: UUID,
        github_repo_id: int,
        access_token: str
    ) -> GitRepository:
        """Connect GitHub repository to workspace and create webhook."""
        # Fetch repo details from GitHub
        g = Github(access_token)
        repo = g.get_repo(github_repo_id)

        # Create webhook
        webhook_secret = secrets.token_urlsafe(32)
        webhook = repo.create_hook(
            name='web',
            config={
                'url': WEBHOOK_URL,
                'content_type': 'json',
                'secret': webhook_secret,
            },
            events=['pull_request', 'pull_request_review', 'push', 'check_suite'],
            active=True
        )

        # Create GitRepository record
        git_repo = GitRepository(
            workspace_id=workspace_id,
            github_repo_id=repo.id,
            owner=repo.owner.login,
            name=repo.name,
            full_name=repo.full_name,
            default_branch=repo.default_branch,
            webhook_id=webhook.id,
            webhook_secret=encrypt_webhook_secret(webhook_secret)
        )

        self.db.add(git_repo)
        await self.db.commit()
        await self.db.refresh(git_repo)
        return git_repo

    async def disconnect_repository(self, repo_id: UUID, access_token: str) -> None:
        """Disconnect repository and remove webhook."""
        repo = await self.db.get(GitRepository, repo_id)
        if not repo:
            raise ValueError("Repository not found")

        # Delete GitHub webhook
        if repo.webhook_id:
            try:
                g = Github(access_token)
                gh_repo = g.get_repo(repo.github_repo_id)
                hook = gh_repo.get_hook(repo.webhook_id)
                hook.delete()
            except Exception as e:
                # Log error but continue (webhook might already be deleted)
                print(f"Failed to delete webhook: {e}")

        # Soft delete repository
        repo.is_active = False
        repo.webhook_id = None
        repo.webhook_secret = None

        await self.db.commit()
```

### Webhook Secret Encryption

```python
# backend/app/core/security.py (add to existing file)
from cryptography.fernet import Fernet
import os
import base64

ENCRYPTION_KEY = os.getenv("WEBHOOK_ENCRYPTION_KEY")
if not ENCRYPTION_KEY:
    raise ValueError("WEBHOOK_ENCRYPTION_KEY not set in environment")

cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_webhook_secret(secret: str) -> str:
    """Encrypt webhook secret for storage."""
    encrypted = cipher_suite.encrypt(secret.encode())
    return base64.b64encode(encrypted).decode()

def decrypt_webhook_secret(encrypted_secret: str) -> str:
    """Decrypt webhook secret for use."""
    encrypted = base64.b64decode(encrypted_secret.encode())
    decrypted = cipher_suite.decrypt(encrypted)
    return decrypted.decode()
```

### Frontend Repository Selector

```typescript
// frontend/src/components/workspace/repository-selector.tsx
'use client'

import { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar'
import { Badge } from '@/components/ui/badge'
import { Search, GitBranch } from 'lucide-react'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

interface RepositorySelectorProps {
  workspaceId: string
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function RepositorySelector({ workspaceId, open, onOpenChange }: RepositorySelectorProps) {
  const [search, setSearch] = useState('')
  const [page, setPage] = useState(1)
  const queryClient = useQueryClient()

  const { data: repos, isLoading } = useQuery({
    queryKey: ['available-repositories', workspaceId, page],
    queryFn: () => api.get(`/workspaces/${workspaceId}/repositories/available?page=${page}`),
    enabled: open,
  })

  const connectMutation = useMutation({
    mutationFn: (githubRepoId: number) =>
      api.post(`/workspaces/${workspaceId}/repositories`, { github_repo_id: githubRepoId }),
    onSuccess: () => {
      toast.success('Repository connected')
      queryClient.invalidateQueries({ queryKey: ['workspace-repositories', workspaceId] })
      onOpenChange(false)
    },
    onError: (error: any) => {
      toast.error(error.message || 'Failed to connect repository')
    },
  })

  const filteredRepos = repos?.filter((repo: any) =>
    repo.full_name.toLowerCase().includes(search.toLowerCase())
  ) || []

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[600px]">
        <DialogHeader>
          <DialogTitle>Connect Repository</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div className="relative">
            <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search repositories..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="pl-9"
            />
          </div>

          <div className="space-y-2 max-h-[400px] overflow-y-auto">
            {isLoading ? (
              <div className="text-center py-8 text-muted-foreground">Loading repositories...</div>
            ) : filteredRepos.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">No repositories found</div>
            ) : (
              filteredRepos.map((repo: any) => (
                <div
                  key={repo.id}
                  className="flex items-center justify-between p-3 border rounded-lg hover:bg-muted/50"
                >
                  <div className="flex items-center gap-3">
                    <Avatar className="h-10 w-10">
                      <AvatarImage src={repo.avatar_url} />
                      <AvatarFallback>{repo.owner[0]}</AvatarFallback>
                    </Avatar>
                    <div>
                      <p className="font-medium">{repo.full_name}</p>
                      <div className="flex items-center gap-2 text-sm text-muted-foreground">
                        <GitBranch className="h-3 w-3" />
                        {repo.default_branch}
                      </div>
                    </div>
                  </div>
                  <Button
                    size="sm"
                    onClick={() => connectMutation.mutate(repo.id)}
                    disabled={connectMutation.isPending}
                  >
                    Connect
                  </Button>
                </div>
              ))
            )}
          </div>

          {repos && repos.length >= 30 && (
            <Button
              variant="outline"
              onClick={() => setPage(page + 1)}
              className="w-full"
            >
              Load More
            </Button>
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

### Testing

**Integration Test - Repository Connection:**
```python
@pytest.mark.asyncio
async def test_connect_repository(client, test_workspace, admin_headers, mock_github):
    response = await client.post(
        f"/workspaces/{test_workspace.id}/repositories",
        json={"github_repo_id": 12345},
        headers=admin_headers
    )
    assert response.status_code == 201
    data = response.json()
    assert data["full_name"] == "owner/repo"
    assert data["webhook_id"] is not None
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 3 Story 3.1 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
