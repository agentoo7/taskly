# Story 5.4: Advanced Bulk Operations & Batch Editing

## Status
Draft

---

## Story

**As a** board member,
**I want** powerful bulk editing capabilities for selected cards,
**so that** I can quickly update multiple cards with consistent changes.

---

## Acceptance Criteria

1. Floating toolbar (Story 5.3) includes "Edit Multiple" button opening bulk edit modal
2. Bulk edit modal displays fields: Title Prefix/Suffix (add text to all titles), Description Append (add text to end of all descriptions), Assignees (add/remove), Labels (add/remove), Priority (set), Story Points (set or adjust by +/- amount), Due Date (set or offset by days), Sprint Assignment
3. Field-level checkboxes: user selects which fields to update (prevents accidental overwrites)
4. Preview section in modal shows first 3 affected cards with before/after comparison for selected fields
5. Title prefix/suffix examples: prefix "URGENT: " to all selected cards, suffix " (deprecated)" to cards
6. Assignees bulk action modes: "Add assignees to existing" (keeps current, adds new), "Replace all assignees" (removes current, sets new), "Remove specific assignees" (unassign selected members)
7. Labels bulk action similar: "Add labels", "Replace labels", "Remove labels" modes
8. Story points adjustment: "Set to value" (overwrite), "Increase by X", "Decrease by X" modes
9. Due date operations: "Set to specific date", "Add X days to existing dates", "Remove due dates"
10. Sprint assignment: "Assign to sprint" (dropdown), "Remove from sprint" (moves to backlog)
11. Applying bulk edit executes single `POST /api/cards/bulk-update` request with all changes; backend processes in database transaction (all or nothing)
12. Progress indicator during bulk update: "Updating 25 cards..." with spinner; success message: "25 cards updated successfully"
13. Error handling: if bulk update fails for some cards (e.g., validation errors), shows partial success message: "20 of 25 cards updated. 5 failed." with details button expanding error list
14. Undo support: bulk edit actions added to undo stack; Ctrl+Z reverts entire bulk operation (restores all changed cards to previous state)
15. Activity log: single aggregated entry "[User] bulk updated 25 cards (changed priority, added labels)" rather than 25 separate entries
16. Bulk operations respect permissions: cards user lacks edit permission for are excluded from bulk update with warning: "2 cards skipped (no edit permission)"
17. Rate limiting protection: bulk updates >100 cards chunked into batches of 50 with brief delays to prevent database overload

---

## Tasks / Subtasks

- [ ] **Task 1: Create bulk edit modal** (AC: 1, 2, 3)
  - [ ] Create `frontend/src/components/board/bulk-edit-modal.tsx`
  - [ ] Field sections with checkboxes to enable/disable
  - [ ] Title prefix/suffix inputs
  - [ ] Description append textarea
  - [ ] Assignee, label, priority dropdowns
  - [ ] Story points input with adjustment modes
  - [ ] Due date picker with offset options
  - [ ] Sprint assignment dropdown

- [ ] **Task 2: Implement field-level selection** (AC: 3)
  - [ ] Checkbox for each field group
  - [ ] Only include checked fields in update payload
  - [ ] Disable submit if no fields selected
  - [ ] Visual indication of selected fields

- [ ] **Task 3: Build preview section** (AC: 4)
  - [ ] Show first 3 affected cards
  - [ ] Before/after comparison for selected fields
  - [ ] Real-time preview as user changes settings
  - [ ] Highlight changed values

- [ ] **Task 4: Implement title prefix/suffix** (AC: 5)
  - [ ] Prefix input prepends text to titles
  - [ ] Suffix input appends text to titles
  - [ ] Preview shows transformed titles
  - [ ] Apply to all selected cards

- [ ] **Task 5: Add assignee bulk modes** (AC: 6)
  - [ ] Mode selector: Add, Replace, Remove
  - [ ] "Add" keeps existing + adds new
  - [ ] "Replace" clears existing + sets new
  - [ ] "Remove" unassigns specific members
  - [ ] Multi-select assignee dropdown

- [ ] **Task 6: Add label bulk modes** (AC: 7)
  - [ ] Mode selector: Add, Replace, Remove
  - [ ] Same behavior as assignees
  - [ ] Multi-select label dropdown
  - [ ] Preview shows label changes

- [ ] **Task 7: Implement story points adjustment** (AC: 8)
  - [ ] Mode selector: Set, Increase, Decrease
  - [ ] "Set" overwrites existing values
  - [ ] "Increase/Decrease" adjusts by amount
  - [ ] Handle null story points

- [ ] **Task 8: Add due date operations** (AC: 9)
  - [ ] Mode selector: Set, Add days, Remove
  - [ ] Date picker for "Set" mode
  - [ ] Number input for "Add days" mode
  - [ ] "Remove" clears all due dates

- [ ] **Task 9: Implement sprint assignment** (AC: 10)
  - [ ] Sprint dropdown selector
  - [ ] "Remove from sprint" option
  - [ ] Move to backlog when removed

- [ ] **Task 10: Create bulk update service** (AC: 11, 16, 17)
  - [ ] Build update payload from selected fields
  - [ ] Check permissions for each card
  - [ ] Chunk requests if >100 cards
  - [ ] Process in database transaction
  - [ ] Return success/failure counts

- [ ] **Task 11: Add progress indicator** (AC: 12)
  - [ ] Show spinner during update
  - [ ] Display "Updating X cards..." message
  - [ ] Success toast when complete
  - [ ] Show updated count

- [ ] **Task 12: Implement error handling** (AC: 13)
  - [ ] Collect errors from backend
  - [ ] Show partial success message
  - [ ] "Details" button expands error list
  - [ ] Display which cards failed and why

- [ ] **Task 13: Add undo support** (AC: 14)
  - [ ] Capture before state of all cards
  - [ ] Add to undo stack after successful update
  - [ ] Ctrl+Z reverts entire bulk operation
  - [ ] Restore all fields to previous values

- [ ] **Task 14: Implement aggregated activity log** (AC: 15)
  - [ ] Create single activity entry for bulk action
  - [ ] Format: "[User] bulk updated X cards (actions)"
  - [ ] List changed fields in metadata
  - [ ] Link to affected cards

- [ ] **Task 15: Write tests** (AC: 1-17)
  - [ ] Unit test: Field transformation logic
  - [ ] Unit test: Permission filtering
  - [ ] Integration test: Bulk update API
  - [ ] Component test: Preview rendering
  - [ ] E2E test: Full bulk edit workflow

---

## Dev Notes

### Bulk Edit Modal

```typescript
// frontend/src/components/board/bulk-edit-modal.tsx
'use client'

import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Checkbox } from '@/components/ui/checkbox'
import { Label } from '@/components/ui/label'
import { Select } from '@/components/ui/select'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

interface BulkEditPayload {
  titlePrefix?: string
  titleSuffix?: string
  descriptionAppend?: string
  assigneeMode?: 'add' | 'replace' | 'remove'
  assigneeIds?: string[]
  labelMode?: 'add' | 'replace' | 'remove'
  labelIds?: string[]
  priority?: string
  storyPointsMode?: 'set' | 'increase' | 'decrease'
  storyPointsValue?: number
  dueDateMode?: 'set' | 'offset' | 'remove'
  dueDateValue?: string
  dueDateOffset?: number
  sprintId?: string | null
}

export function BulkEditModal({ open, onOpenChange, selectedCardIds, cards }: any) {
  const queryClient = useQueryClient()

  const [enabledFields, setEnabledFields] = useState({
    title: false,
    description: false,
    assignees: false,
    labels: false,
    priority: false,
    storyPoints: false,
    dueDate: false,
    sprint: false,
  })

  const [payload, setPayload] = useState<BulkEditPayload>({
    assigneeMode: 'add',
    labelMode: 'add',
    storyPointsMode: 'set',
    dueDateMode: 'set',
  })

  const selectedCards = cards.filter((c: any) => selectedCardIds.includes(c.id))
  const previewCards = selectedCards.slice(0, 3)

  const bulkEditMutation = useMutation({
    mutationFn: () =>
      api.post('/api/cards/bulk-edit', {
        card_ids: selectedCardIds,
        updates: buildUpdatePayload(),
      }),
    onSuccess: (data) => {
      const { success_count, failed_count, failed_cards } = data

      if (failed_count > 0) {
        toast.error(`${failed_count} cards failed to update`, {
          action: {
            label: 'Details',
            onClick: () => console.log(failed_cards),
          },
        })
      } else {
        toast.success(`${success_count} cards updated successfully`)
      }

      queryClient.invalidateQueries({ queryKey: ['board'] })
      onOpenChange(false)
    },
    onError: () => {
      toast.error('Failed to update cards')
    },
  })

  const buildUpdatePayload = () => {
    const updates: any = {}

    if (enabledFields.title) {
      if (payload.titlePrefix) updates.titlePrefix = payload.titlePrefix
      if (payload.titleSuffix) updates.titleSuffix = payload.titleSuffix
    }

    if (enabledFields.description && payload.descriptionAppend) {
      updates.descriptionAppend = payload.descriptionAppend
    }

    if (enabledFields.assignees) {
      updates.assigneeMode = payload.assigneeMode
      updates.assigneeIds = payload.assigneeIds
    }

    if (enabledFields.labels) {
      updates.labelMode = payload.labelMode
      updates.labelIds = payload.labelIds
    }

    if (enabledFields.priority) {
      updates.priority = payload.priority
    }

    if (enabledFields.storyPoints) {
      updates.storyPointsMode = payload.storyPointsMode
      updates.storyPointsValue = payload.storyPointsValue
    }

    if (enabledFields.dueDate) {
      updates.dueDateMode = payload.dueDateMode
      if (payload.dueDateMode === 'set') updates.dueDateValue = payload.dueDateValue
      if (payload.dueDateMode === 'offset') updates.dueDateOffset = payload.dueDateOffset
    }

    if (enabledFields.sprint) {
      updates.sprintId = payload.sprintId
    }

    return updates
  }

  const getPreviewValue = (card: any, field: string) => {
    if (!enabledFields[field as keyof typeof enabledFields]) {
      return card[field]
    }

    // Apply transformation based on field
    switch (field) {
      case 'title':
        let title = card.title
        if (payload.titlePrefix) title = payload.titlePrefix + title
        if (payload.titleSuffix) title = title + payload.titleSuffix
        return title

      case 'description':
        let desc = card.description || ''
        if (payload.descriptionAppend) desc += '\n\n' + payload.descriptionAppend
        return desc

      case 'storyPoints':
        if (payload.storyPointsMode === 'set') return payload.storyPointsValue
        if (payload.storyPointsMode === 'increase') {
          return (card.storyPoints || 0) + (payload.storyPointsValue || 0)
        }
        if (payload.storyPointsMode === 'decrease') {
          return Math.max(0, (card.storyPoints || 0) - (payload.storyPointsValue || 0))
        }
        return card.storyPoints

      default:
        return card[field]
    }
  }

  const hasEnabledFields = Object.values(enabledFields).some(Boolean)

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-[800px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Edit {selectedCardIds.length} Cards</DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Title */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Checkbox
                checked={enabledFields.title}
                onCheckedChange={(checked) =>
                  setEnabledFields({ ...enabledFields, title: !!checked })
                }
              />
              <Label className="font-semibold">Title</Label>
            </div>
            {enabledFields.title && (
              <div className="ml-6 space-y-2">
                <Input
                  placeholder="Prefix (e.g., URGENT: )"
                  value={payload.titlePrefix || ''}
                  onChange={(e) => setPayload({ ...payload, titlePrefix: e.target.value })}
                />
                <Input
                  placeholder="Suffix (e.g.,  (deprecated))"
                  value={payload.titleSuffix || ''}
                  onChange={(e) => setPayload({ ...payload, titleSuffix: e.target.value })}
                />
              </div>
            )}
          </div>

          {/* Description */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Checkbox
                checked={enabledFields.description}
                onCheckedChange={(checked) =>
                  setEnabledFields({ ...enabledFields, description: !!checked })
                }
              />
              <Label className="font-semibold">Description</Label>
            </div>
            {enabledFields.description && (
              <div className="ml-6">
                <Textarea
                  placeholder="Text to append to all descriptions"
                  value={payload.descriptionAppend || ''}
                  onChange={(e) => setPayload({ ...payload, descriptionAppend: e.target.value })}
                  rows={3}
                />
              </div>
            )}
          </div>

          {/* Assignees */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Checkbox
                checked={enabledFields.assignees}
                onCheckedChange={(checked) =>
                  setEnabledFields({ ...enabledFields, assignees: !!checked })
                }
              />
              <Label className="font-semibold">Assignees</Label>
            </div>
            {enabledFields.assignees && (
              <div className="ml-6 space-y-2">
                <Select
                  value={payload.assigneeMode}
                  onValueChange={(value: any) =>
                    setPayload({ ...payload, assigneeMode: value })
                  }
                >
                  <option value="add">Add to existing</option>
                  <option value="replace">Replace all</option>
                  <option value="remove">Remove specific</option>
                </Select>
                {/* Multi-select assignee dropdown */}
              </div>
            )}
          </div>

          {/* Story Points */}
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Checkbox
                checked={enabledFields.storyPoints}
                onCheckedChange={(checked) =>
                  setEnabledFields({ ...enabledFields, storyPoints: !!checked })
                }
              />
              <Label className="font-semibold">Story Points</Label>
            </div>
            {enabledFields.storyPoints && (
              <div className="ml-6 flex gap-2">
                <Select
                  value={payload.storyPointsMode}
                  onValueChange={(value: any) =>
                    setPayload({ ...payload, storyPointsMode: value })
                  }
                >
                  <option value="set">Set to</option>
                  <option value="increase">Increase by</option>
                  <option value="decrease">Decrease by</option>
                </Select>
                <Input
                  type="number"
                  min="0"
                  value={payload.storyPointsValue || ''}
                  onChange={(e) =>
                    setPayload({ ...payload, storyPointsValue: parseInt(e.target.value) })
                  }
                />
              </div>
            )}
          </div>

          {/* Preview */}
          {hasEnabledFields && previewCards.length > 0 && (
            <div className="border-t pt-4">
              <h4 className="text-sm font-semibold mb-2">Preview (first 3 cards)</h4>
              <div className="space-y-2">
                {previewCards.map((card: any) => (
                  <div key={card.id} className="text-xs space-y-1 p-2 bg-muted rounded">
                    <div className="font-medium">{card.title}</div>
                    {enabledFields.title && (
                      <div className="flex gap-2">
                        <span className="text-muted-foreground">→</span>
                        <span className="font-medium text-blue-600">
                          {getPreviewValue(card, 'title')}
                        </span>
                      </div>
                    )}
                    {enabledFields.storyPoints && (
                      <div className="flex gap-2">
                        <span className="text-muted-foreground">
                          Points: {card.storyPoints || 0} →{' '}
                        </span>
                        <span className="text-blue-600">
                          {getPreviewValue(card, 'storyPoints')}
                        </span>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button
            onClick={() => bulkEditMutation.mutate()}
            disabled={!hasEnabledFields || bulkEditMutation.isPending}
          >
            {bulkEditMutation.isPending
              ? `Updating ${selectedCardIds.length} cards...`
              : `Update ${selectedCardIds.length} cards`}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

### Bulk Edit API Endpoint

```python
# backend/app/api/cards.py
@router.post("/bulk-edit")
async def bulk_edit_cards(
    card_ids: list[UUID],
    updates: dict,
    db: AsyncSession = Depends(get_db),
    current_user = Depends(get_current_user),
):
    """Advanced bulk editing with field transformations."""
    success_count = 0
    failed_cards = []
    before_state = {}

    # Check permissions
    accessible_card_ids = []
    for card_id in card_ids:
        card = await db.get(Card, card_id)
        if card and await check_edit_permission(card, current_user):
            accessible_card_ids.append(card_id)
            before_state[str(card_id)] = card_to_dict(card)
        else:
            failed_cards.append({"card_id": card_id, "error": "No edit permission"})

    if len(accessible_card_ids) != len(card_ids):
        # Log warning about skipped cards
        pass

    # Process in batches of 50
    batch_size = 50
    for i in range(0, len(accessible_card_ids), batch_size):
        batch = accessible_card_ids[i:i + batch_size]

        async with db.begin():
            for card_id in batch:
                try:
                    card = await db.get(Card, card_id)

                    # Apply transformations
                    if 'titlePrefix' in updates:
                        card.title = updates['titlePrefix'] + card.title
                    if 'titleSuffix' in updates:
                        card.title = card.title + updates['titleSuffix']

                    if 'descriptionAppend' in updates:
                        card.description = (card.description or '') + '\n\n' + updates['descriptionAppend']

                    if 'assigneeMode' in updates:
                        if updates['assigneeMode'] == 'add':
                            existing = set(a.id for a in card.assignees)
                            new_ids = set(updates['assigneeIds'])
                            card.assignees = [await db.get(User, uid) for uid in existing | new_ids]
                        elif updates['assigneeMode'] == 'replace':
                            card.assignees = [await db.get(User, uid) for uid in updates['assigneeIds']]
                        elif updates['assigneeMode'] == 'remove':
                            existing = [a for a in card.assignees if str(a.id) not in updates['assigneeIds']]
                            card.assignees = existing

                    if 'priority' in updates:
                        card.priority = updates['priority']

                    if 'storyPointsMode' in updates:
                        if updates['storyPointsMode'] == 'set':
                            card.story_points = updates['storyPointsValue']
                        elif updates['storyPointsMode'] == 'increase':
                            card.story_points = (card.story_points or 0) + updates['storyPointsValue']
                        elif updates['storyPointsMode'] == 'decrease':
                            card.story_points = max(0, (card.story_points or 0) - updates['storyPointsValue'])

                    if 'dueDateMode' in updates:
                        if updates['dueDateMode'] == 'set':
                            card.due_date = updates['dueDateValue']
                        elif updates['dueDateMode'] == 'offset':
                            if card.due_date:
                                card.due_date = card.due_date + timedelta(days=updates['dueDateOffset'])
                        elif updates['dueDateMode'] == 'remove':
                            card.due_date = None

                    if 'sprintId' in updates:
                        card.sprint_id = updates['sprintId']

                    success_count += 1

                except Exception as e:
                    failed_cards.append({"card_id": card_id, "error": str(e)})

        # Brief delay between batches
        if i + batch_size < len(accessible_card_ids):
            await asyncio.sleep(0.1)

    # Log aggregated activity
    changed_fields = [k for k in updates.keys() if k not in ['assigneeMode', 'storyPointsMode', 'dueDateMode']]
    CardActivity.create(
        card_id=accessible_card_ids[0],
        action=ActivityAction.BULK_UPDATED,
        user_id=current_user.id,
        metadata={
            "count": success_count,
            "fields": changed_fields,
            "before_state": before_state,
        }
    )

    return {
        "success_count": success_count,
        "failed_count": len(failed_cards),
        "failed_cards": failed_cards,
        "before_state": before_state,  # For undo support
    }
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 5 Story 5.4 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
