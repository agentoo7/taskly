# Story 2.5: Drag-and-Drop Card Movement

## Status
Draft

---

## Story

**As a** board member,
**I want** to drag and drop cards between columns and reorder within columns,
**so that** I can easily update task status and prioritization.

---

## Acceptance Criteria

1. Cards draggable by grabbing anywhere on card surface (entire card is drag handle)
2. Dragging card shows semi-transparent drag preview following cursor
3. Dropping card in same column updates position (reorders cards)
4. Dropping card in different column updates both `column_id` and `position` fields
5. Drop zones (columns) highlighted with border or background color when dragging card over them
6. Card positions automatically recalculated: dropped card gets new position, other cards shift up/down
7. Drag operation supports keyboard navigation: Space to grab, Arrow keys to move, Enter to drop, Escape to cancel
8. Optimistic UI update: card moves immediately on drop, rolls back if API call fails
9. Real-time synchronization: other users see card movement within 500ms via WebSocket
10. Cannot drag cards to archived boards (drag disabled, visual indicator shows board is read-only)
11. Mobile touch support: long-press card to initiate drag, drag with finger, release to drop
12. Bulk move operation: select multiple cards (checkbox on card), drag selection to new column as group
13. Undo action available for 5 seconds after move (toast notification with "Undo" button)
14. Activity log records card movements: "[User] moved card from [Column A] to [Column B]"

---

## Tasks / Subtasks

- [ ] **Task 1: Create card movement API endpoint** (AC: 3, 4, 6, 14)
  - [ ] Implement `PATCH /cards/{id}/move` - move card to new column/position
  - [ ] Accept: `column_id` (UUID), `position` (int) in request body
  - [ ] Calculate position shifts for affected cards
  - [ ] If same column: reorder cards between old and new position
  - [ ] If different column: remove from old column (shift down), insert in new column (shift up)
  - [ ] Return updated card and affected cards list
  - [ ] Log activity: create CardActivity record with action "moved"

- [ ] **Task 2: Implement position recalculation logic** (AC: 6)
  - [ ] Create `backend/app/services/card_movement_service.py`
  - [ ] Implement `move_card(card_id, target_column_id, target_position)` method
  - [ ] Handle same-column reordering: shift cards between old and new positions
  - [ ] Handle cross-column movement: decrement positions in source column, increment in target column
  - [ ] Use database transactions to ensure atomic position updates
  - [ ] Optimize with bulk update queries (avoid N+1 problem)

- [ ] **Task 3: Set up drag-and-drop with @dnd-kit** (AC: 1, 2, 5, 7)
  - [ ] Install @dnd-kit: `@dnd-kit/core`, `@dnd-kit/sortable`, `@dnd-kit/utilities`
  - [ ] Wrap board view with `DndContext` provider
  - [ ] Configure sensors: PointerSensor (mouse/touch), KeyboardSensor (keyboard nav)
  - [ ] Implement custom collision detection for multi-column layout
  - [ ] Create drag overlay component showing card preview during drag
  - [ ] Add visual drop indicators (highlight target column, show insertion line)

- [ ] **Task 4: Make cards draggable within columns** (AC: 1, 3, 6)
  - [ ] Update `BoardCard` component to use `useSortable` hook from @dnd-kit
  - [ ] Set card ID as sortable identifier
  - [ ] Apply drag handle attributes to entire card surface
  - [ ] Show transform styles during drag (translate, opacity)
  - [ ] Implement `onDragEnd` handler to detect position changes
  - [ ] Calculate new position based on drop index

- [ ] **Task 5: Enable cross-column card dragging** (AC: 4, 5, 6)
  - [ ] Update `BoardColumn` component to be droppable target
  - [ ] Use `useDroppable` hook for columns
  - [ ] Highlight column when card dragged over it (border color change)
  - [ ] Calculate target position based on drop Y-coordinate within column
  - [ ] Handle edge cases: dropping at top (position 0), dropping at bottom (max position)
  - [ ] Update both `column_id` and `position` on drop

- [ ] **Task 6: Implement optimistic UI updates** (AC: 8)
  - [ ] On drag end, immediately update card position in local state
  - [ ] Call `PATCH /cards/{id}/move` API endpoint
  - [ ] On success, invalidate board query to refresh from server
  - [ ] On error, rollback local state to previous positions
  - [ ] Show error toast: "Failed to move card. Changes reverted."
  - [ ] Use TanStack Query mutation with onMutate/onError/onSettled callbacks

- [ ] **Task 7: Add keyboard navigation for drag-and-drop** (AC: 7)
  - [ ] Configure KeyboardSensor with coordinateGetter
  - [ ] Space bar to activate drag mode on focused card
  - [ ] Arrow keys to move card up/down within column or left/right between columns
  - [ ] Enter to drop card at current position
  - [ ] Escape to cancel drag and return card to original position
  - [ ] Announce state changes to screen readers (ARIA live regions)

- [ ] **Task 8: Add mobile touch support** (AC: 11)
  - [ ] Configure TouchSensor in DndContext
  - [ ] Set activation constraint: long press for 250ms before drag starts
  - [ ] Show visual feedback on touch: scale card slightly when active
  - [ ] Support scroll-while-dragging on mobile (auto-scroll columns)
  - [ ] Test on iOS Safari and Android Chrome
  - [ ] Add haptic feedback on drag start/drop (if supported)

- [ ] **Task 9: Implement real-time card movement sync** (AC: 9)
  - [ ] Backend broadcasts `card_moved` WebSocket event on move
  - [ ] Event payload: card_id, old_column_id, new_column_id, new_position, moved_by user
  - [ ] Frontend subscribes to board WebSocket room
  - [ ] On `card_moved` event, update card in local state
  - [ ] If card moved by another user, animate card transition (slide animation)
  - [ ] Show toast: "[User] moved card to [Column]"

- [ ] **Task 10: Add undo functionality** (AC: 13)
  - [ ] Store last card move in Zustand store: previous_column_id, previous_position
  - [ ] Show toast after move with "Undo" button (5 second timeout)
  - [ ] On undo click, call move API with previous coordinates
  - [ ] Clear undo state after timeout or new move
  - [ ] Disable undo if another user moved the same card

- [ ] **Task 11: Implement bulk card selection and move** (AC: 12)
  - [ ] Add checkbox to card component (visible on hover or always)
  - [ ] Use Zustand store to track selected card IDs: `selectedCards: Set<UUID>`
  - [ ] Show selection count in board header: "3 cards selected"
  - [ ] Dragging any selected card drags entire selection
  - [ ] Show special drag preview: stacked cards with count badge
  - [ ] API endpoint: `PATCH /cards/bulk-move` accepts card_ids array and target column/position
  - [ ] Clear selection after bulk move

- [ ] **Task 12: Add card activity logging** (AC: 14)
  - [ ] Create `CardActivity` model if not exists (from Story 1.3)
  - [ ] On card move, create activity record: action="moved", metadata={from_column, to_column}
  - [ ] Store user who performed action and timestamp
  - [ ] Display in card activity timeline (will implement in Story 2.7)
  - [ ] Include column names in activity description (not just IDs)

- [ ] **Task 13: Handle archived board restrictions** (AC: 10)
  - [ ] Check board.archived status before allowing drag
  - [ ] Disable drag sensors when board is archived
  - [ ] Show read-only banner at top of archived board
  - [ ] Display tooltip on card hover: "Cards cannot be moved in archived boards"
  - [ ] Allow viewing card details but disable editing

- [ ] **Task 14: Write tests for drag-and-drop** (AC: 1-14)
  - [ ] Unit test: Card movement service correctly recalculates positions
  - [ ] Unit test: Same-column reordering logic
  - [ ] Unit test: Cross-column movement logic
  - [ ] Integration test: Move card API endpoint
  - [ ] Integration test: Bulk move endpoint
  - [ ] Component test: Card drag simulation with @dnd-kit
  - [ ] E2E test: Drag card from one column to another
  - [ ] E2E test: Undo card movement

---

## Dev Notes

### Card Movement Service

```python
# backend/app/services/card_movement_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import update, select, and_
from app.models.card import Card
from app.models.card_activity import CardActivity
from uuid import UUID

class CardMovementService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def move_card(
        self,
        card_id: UUID,
        target_column_id: UUID,
        target_position: int,
        moved_by: UUID
    ) -> Card:
        """Move card to new column/position with atomic position recalculation."""
        async with self.db.begin():
            # Get card
            card = await self.db.get(Card, card_id)
            if not card:
                raise ValueError("Card not found")

            old_column_id = card.column_id
            old_position = card.position
            board_id = card.board_id

            if old_column_id == target_column_id:
                # Same column: reorder
                await self._reorder_within_column(
                    board_id, old_column_id, old_position, target_position
                )
            else:
                # Different column: remove from old, insert in new
                await self._remove_from_column(board_id, old_column_id, old_position)
                await self._insert_into_column(board_id, target_column_id, target_position)

            # Update card
            card.column_id = target_column_id
            card.position = target_position
            await self.db.flush()

            # Log activity
            activity = CardActivity(
                card_id=card_id,
                user_id=moved_by,
                action="moved",
                metadata={
                    "from_column": str(old_column_id),
                    "to_column": str(target_column_id),
                    "from_position": old_position,
                    "to_position": target_position
                }
            )
            self.db.add(activity)

            await self.db.flush()
            await self.db.refresh(card)
            return card

    async def _reorder_within_column(
        self,
        board_id: UUID,
        column_id: UUID,
        old_position: int,
        new_position: int
    ):
        """Reorder cards within same column."""
        if old_position < new_position:
            # Moving down: shift cards between old and new position up
            await self.db.execute(
                update(Card)
                .where(
                    and_(
                        Card.board_id == board_id,
                        Card.column_id == column_id,
                        Card.position > old_position,
                        Card.position <= new_position
                    )
                )
                .values(position=Card.position - 1)
            )
        else:
            # Moving up: shift cards between new and old position down
            await self.db.execute(
                update(Card)
                .where(
                    and_(
                        Card.board_id == board_id,
                        Card.column_id == column_id,
                        Card.position >= new_position,
                        Card.position < old_position
                    )
                )
                .values(position=Card.position + 1)
            )

    async def _remove_from_column(self, board_id: UUID, column_id: UUID, position: int):
        """Remove card from column by shifting cards below up."""
        await self.db.execute(
            update(Card)
            .where(
                and_(
                    Card.board_id == board_id,
                    Card.column_id == column_id,
                    Card.position > position
                )
            )
            .values(position=Card.position - 1)
        )

    async def _insert_into_column(self, board_id: UUID, column_id: UUID, position: int):
        """Insert card into column by shifting cards at/below position down."""
        await self.db.execute(
            update(Card)
            .where(
                and_(
                    Card.board_id == board_id,
                    Card.column_id == column_id,
                    Card.position >= position
                )
            )
            .values(position=Card.position + 1)
        )
```

### Frontend Drag-and-Drop Implementation

```typescript
// Update to frontend/src/app/(dashboard)/workspaces/[workspaceId]/boards/[boardId]/page.tsx
'use client'

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import {
  DndContext,
  DragOverlay,
  closestCorners,
  KeyboardSensor,
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragOverEvent,
  DragEndEvent,
} from '@dnd-kit/core'
import { arrayMove } from '@dnd-kit/sortable'
import { BoardColumn } from '@/components/board/board-column'
import { BoardCard } from '@/components/board/board-card'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

export default function BoardPage({ params }: { params: { boardId: string } }) {
  const [activeCard, setActiveCard] = useState(null)
  const queryClient = useQueryClient()

  const { data: board } = useQuery({
    queryKey: ['boards', params.boardId],
    queryFn: () => api.get(`/boards/${params.boardId}`),
  })

  const moveCardMutation = useMutation({
    mutationFn: ({ cardId, columnId, position }: any) =>
      api.patch(`/cards/${cardId}/move`, { column_id: columnId, position }),
    onMutate: async ({ cardId, columnId, position }) => {
      // Optimistic update
      await queryClient.cancelQueries({ queryKey: ['boards', params.boardId] })
      const previous = queryClient.getQueryData(['boards', params.boardId])

      queryClient.setQueryData(['boards', params.boardId], (old: any) => {
        // Update card position locally
        const card = old.cards.find((c: any) => c.id === cardId)
        if (!card) return old

        const updatedCards = old.cards.map((c: any) => {
          if (c.id === cardId) {
            return { ...c, column_id: columnId, position }
          }
          return c
        })

        return { ...old, cards: updatedCards }
      })

      return { previous }
    },
    onError: (err, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['boards', params.boardId], context?.previous)
      toast.error('Failed to move card. Changes reverted.')
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['boards', params.boardId] })

      // Show undo toast
      toast.success('Card moved', {
        action: {
          label: 'Undo',
          onClick: () => {
            // Implement undo logic
          },
        },
        duration: 5000,
      })
    },
  })

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px movement required to start drag
      },
    }),
    useSensor(TouchSensor, {
      activationConstraint: {
        delay: 250,
        tolerance: 5,
      },
    }),
    useSensor(KeyboardSensor)
  )

  const handleDragStart = (event: DragStartEvent) => {
    const { active } = event
    const card = board.cards.find((c: any) => c.id === active.id)
    setActiveCard(card)
  }

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event
    setActiveCard(null)

    if (!over) return

    const activeCard = board.cards.find((c: any) => c.id === active.id)
    const overId = over.id

    // Determine target column and position
    let targetColumnId: string
    let targetPosition: number

    // Check if dropped over a column or another card
    const overColumn = board.columns.find((col: any) => col.id === overId)
    if (overColumn) {
      // Dropped over column (empty space)
      targetColumnId = overColumn.id
      targetPosition = 0 // Top of column
    } else {
      // Dropped over another card
      const overCard = board.cards.find((c: any) => c.id === overId)
      targetColumnId = overCard.column_id
      targetPosition = overCard.position
    }

    // Move card
    moveCardMutation.mutate({
      cardId: activeCard.id,
      columnId: targetColumnId,
      position: targetPosition,
    })
  }

  if (!board) return <div>Loading...</div>

  return (
    <div className="flex flex-col h-full">
      <div className="border-b p-4">
        <h1 className="text-2xl font-bold">{board.name}</h1>
      </div>

      <div className="flex-1 overflow-x-auto p-4">
        <DndContext
          sensors={sensors}
          collisionDetection={closestCorners}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
        >
          <div className="flex gap-4">
            {board.columns.map((column: any) => (
              <BoardColumn
                key={column.id}
                column={column}
                cards={board.cards.filter((c: any) => c.column_id === column.id)}
              />
            ))}
          </div>

          <DragOverlay>
            {activeCard ? <BoardCard card={activeCard} isDragging /> : null}
          </DragOverlay>
        </DndContext>
      </div>
    </div>
  )
}
```

### Testing

**Unit Test - Position Recalculation:**
```python
@pytest.mark.asyncio
async def test_move_card_between_columns(db_session, test_board):
    service = CardMovementService(db_session)

    # Create cards in column A
    col_a = test_board.columns[0]["id"]
    col_b = test_board.columns[1]["id"]

    card1 = Card(board_id=test_board.id, column_id=col_a, title="Card 1", position=0)
    card2 = Card(board_id=test_board.id, column_id=col_a, title="Card 2", position=1)
    card3 = Card(board_id=test_board.id, column_id=col_b, title="Card 3", position=0)

    db_session.add_all([card1, card2, card3])
    await db_session.commit()

    # Move card2 from col_a to col_b at position 0
    await service.move_card(card2.id, col_b, 0, test_user.id)

    await db_session.refresh(card1)
    await db_session.refresh(card2)
    await db_session.refresh(card3)

    assert card2.column_id == col_b
    assert card2.position == 0
    assert card3.position == 1  # Shifted down
    assert card1.position == 0  # Shifted up in old column
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 2 Story 2.5 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
