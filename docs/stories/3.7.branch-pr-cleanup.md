# Story 3.7: Branch & PR Cleanup

## Status
Draft

---

## Story

**As a** workspace admin,
**I want** automated cleanup of merged branches and closed PRs,
**so that** my repository stays organized without manual maintenance.

---

## Acceptance Criteria

1. Board settings include "Auto-delete merged branches" toggle (default: off)
2. When PR merged and auto-delete enabled, branch automatically deleted from GitHub via API
3. Branch deletion adds activity entry: "deleted branch [branch-name] (PR #123 merged)"
4. Deleted branches preserved in card metadata for historical record
5. Card shows "Branch deleted" badge if branch no longer exists on GitHub
6. Board settings include stale PR detection: "Mark PRs stale after X days of inactivity" (default: 14 days)
7. Stale PRs show yellow "Stale" badge on card
8. Stale PR notification sent to card creator: "PR #123 has been inactive for 14 days"
9. Admin can bulk cleanup: "Delete all merged branches" button in repository settings
10. Bulk cleanup shows confirmation with count: "Delete 12 merged branches?"
11. Cleanup logs activity for each deleted branch
12. Cleanup respects protected branches (never deletes main, master, develop, etc.)

---

## Tasks / Subtasks

- [ ] **Task 1: Add cleanup settings to Board model** (AC: 1, 6)
  - [ ] Add `auto_delete_branches` boolean
  - [ ] Add `stale_pr_days` integer (default 14)

- [ ] **Task 2: Implement auto-delete on PR merge** (AC: 2, 3, 4)
  - [ ] In PR merge webhook, check auto_delete_branches setting
  - [ ] Call GitHub API: `DELETE /repos/{owner}/{repo}/git/refs/heads/{branch}`
  - [ ] Log activity, update card metadata

- [ ] **Task 3: Add branch deleted indicator** (AC: 5)
  - [ ] Check if branch exists on GitHub
  - [ ] Show "Branch deleted" badge if not found
  - [ ] Badge is informational, not an error

- [ ] **Task 4: Implement stale PR detection** (AC: 6, 7, 8)
  - [ ] Celery periodic task checks PR last_updated_at
  - [ ] If > stale_pr_days, mark as stale
  - [ ] Create notification for card creator

- [ ] **Task 5: Add bulk cleanup UI** (AC: 9, 10, 11)
  - [ ] Add "Cleanup" section to repository settings
  - [ ] "Delete all merged branches" button
  - [ ] Confirmation modal with count
  - [ ] Batch delete via GitHub API

- [ ] **Task 6: Implement protected branch check** (AC: 12)
  - [ ] Fetch protected branches from GitHub API
  - [ ] Never delete branches matching protected list
  - [ ] Default protect: main, master, develop, staging, production

- [ ] **Task 7: Write tests** (AC: 1-12)
  - [ ] Unit test: Protected branch detection
  - [ ] Integration test: Auto-delete after merge
  - [ ] Integration test: Stale PR detection

---

## Dev Notes

### Protected Branches Configuration

**Problem:** Hardcoded protected branch list doesn't adapt to project-specific naming conventions.

**Solution: Dynamic Protected Branch Management**

```python
# Default protected branches (repository-level setting)
DEFAULT_PROTECTED_BRANCHES = ['main', 'master', 'develop', 'staging', 'production', 'release/*']

class GitRepository(Base):
    """Extended model with protected branches configuration."""
    __tablename__ = "git_repositories"

    # ... existing fields ...

    protected_branches = Column(JSONB, default=lambda: DEFAULT_PROTECTED_BRANCHES)
    # Supports wildcards: 'release/*', 'hotfix/*'
    last_protected_branches_sync = Column(DateTime(timezone=True))
```

**UI for Protected Branch Management:**

- Repository Settings → "Protected Branches" section
- List of protected branch patterns (editable)
- "+ Add Pattern" button
- Sync button: Fetch from GitHub API and merge with local list
- Warning: "Cleanup will never delete these branches"

**Branch Pattern Matching:**

```python
import fnmatch

def is_protected_branch(branch_name: str, protected_patterns: list[str]) -> bool:
    """Check if branch matches any protected pattern (supports wildcards)."""
    for pattern in protected_patterns:
        if fnmatch.fnmatch(branch_name, pattern):
            return True
    return False

# Examples:
# is_protected_branch("main", ["main", "master"]) → True
# is_protected_branch("release/v1.0", ["release/*"]) → True
# is_protected_branch("feature/foo", ["main", "release/*"]) → False
```

**Sync with GitHub Protected Branches:**

- Celery periodic task (daily) fetches protected branches from GitHub API
- Endpoint: `GET /repos/{owner}/{repo}/branches?protected=true`
- Merges GitHub protected branches with local configuration (union)
- Prevents accidental deletion of GitHub-protected branches

### Error Recovery & Retry Logic

**Problem:** Branch deletion can fail due to GitHub API errors, network issues, or permissions.

**Solution: Comprehensive Error Handling with Retry**

**Error Recovery Workflow:**

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    reraise=True
)
async def delete_branch_with_retry(repo_id: UUID, branch_name: str) -> dict:
    """Delete branch with exponential backoff retry."""
    try:
        repo = await db.get(GitRepository, repo_id)

        # Check protected branch
        if is_protected_branch(branch_name, repo.protected_branches):
            raise ValueError(f"Cannot delete protected branch: {branch_name}")

        # Call GitHub API
        async with httpx.AsyncClient() as client:
            response = await client.delete(
                f"https://api.github.com/repos/{repo.owner}/{repo.name}/git/refs/heads/{branch_name}",
                headers={"Authorization": f"Bearer {repo.access_token}"}
            )

            if response.status_code == 204:
                # Success
                await log_activity(repo_id, "branch_deleted", {"branch": branch_name})
                return {"status": "success", "branch": branch_name}

            elif response.status_code == 404:
                # Branch already deleted (idempotent)
                logger.info(f"Branch {branch_name} already deleted")
                return {"status": "already_deleted", "branch": branch_name}

            elif response.status_code == 403:
                # Permissions error (don't retry)
                raise PermissionError(f"No permission to delete branch: {branch_name}")

            else:
                # Unexpected error (retry)
                response.raise_for_status()

    except httpx.TimeoutException as e:
        logger.warning(f"Timeout deleting branch {branch_name}, will retry")
        raise  # Retry

    except httpx.NetworkError as e:
        logger.warning(f"Network error deleting branch {branch_name}, will retry")
        raise  # Retry

    except PermissionError:
        # Don't retry permission errors
        await log_activity(repo_id, "branch_delete_failed", {
            "branch": branch_name,
            "reason": "permission_denied"
        })
        raise

    except Exception as e:
        logger.error(f"Unexpected error deleting branch {branch_name}: {e}")
        raise
```

**Error Handling Table:**

| Error Type | HTTP Status | User Impact | Recovery Action | Retry? |
|------------|-------------|-------------|-----------------|--------|
| Branch already deleted | 404 | None (idempotent) | Log as success, skip | No |
| Permission denied | 403 | Cleanup fails | Show error in UI, require admin to grant permissions | No |
| Rate limit exceeded | 429 | Cleanup delayed | Wait for rate limit reset, retry after delay | Yes (after delay) |
| Network timeout | N/A | Temporary failure | Exponential backoff retry (3 attempts) | Yes |
| GitHub outage | 500, 502, 503 | Temporary failure | Exponential backoff retry (3 attempts) | Yes |
| Invalid branch name | 422 | Cleanup skipped | Log error, skip this branch | No |

**Bulk Cleanup Error Handling:**

```python
async def bulk_delete_branches(repo_id: UUID, branches: list[str]) -> dict:
    """Delete multiple branches with partial failure handling."""
    results = {
        "success": [],
        "failed": [],
        "skipped": []  # Protected branches
    }

    for branch in branches:
        try:
            result = await delete_branch_with_retry(repo_id, branch)
            if result["status"] in ["success", "already_deleted"]:
                results["success"].append(branch)
        except ValueError as e:
            # Protected branch
            results["skipped"].append({"branch": branch, "reason": str(e)})
        except PermissionError as e:
            # Permission denied
            results["failed"].append({"branch": branch, "error": "permission_denied"})
        except Exception as e:
            # Other errors after retries exhausted
            results["failed"].append({"branch": branch, "error": str(e)})

    # Log summary
    await log_activity(repo_id, "bulk_branch_cleanup", results)

    return results
```

**UI Feedback for Bulk Cleanup:**

```
Cleanup Results:
✅ Deleted 8 branches successfully
⚠️ Skipped 2 protected branches (main, develop)
❌ Failed to delete 1 branch (permission denied: release/v1.0)

[View Details] [Retry Failed]
```

### Notification Preferences

**Problem:** Users may not want stale PR notifications cluttering their inbox.

**Solution: Granular Notification Settings**

**User Model Extension:**

```python
class UserNotificationPreferences(Base):
    """Per-user notification preferences."""
    __tablename__ = "user_notification_preferences"

    user_id = Column(UUID, ForeignKey("users.id"), primary_key=True)
    stale_pr_notifications = Column(Boolean, default=True)  # Enable stale PR notifications
    stale_pr_threshold_days = Column(Integer, default=14)  # Custom threshold per user
    branch_deleted_notifications = Column(Boolean, default=True)
    notification_channels = Column(JSONB, default=lambda: ["in_app", "email"])
    # Channels: "in_app", "email", "slack" (future)
```

**Notification Settings UI:**

Located in: User Profile → Notifications

```
Cleanup & Maintenance Notifications

☑ Stale PR Alerts
   Notify me when my PRs haven't been updated in: [14] days
   Channels: ☑ In-app  ☑ Email

☑ Branch Deletion Notifications
   Notify me when branches are auto-deleted from my cards
   Channels: ☑ In-app  ☐ Email

☐ Bulk Cleanup Summaries
   Send weekly summary of cleanup activities
```

**Notification Logic:**

```python
async def send_stale_pr_notification(pr_id: UUID):
    """Send stale PR notification respecting user preferences."""
    pr = await db.get(PullRequest, pr_id)
    card = await db.get(Card, pr.card_id)
    creator = await db.get(User, card.created_by)

    # Check user preferences
    prefs = await get_user_preferences(creator.id)

    if not prefs.stale_pr_notifications:
        logger.info(f"Skipping stale PR notification for user {creator.id} (disabled)")
        return

    # Use user's custom threshold if set
    threshold_days = prefs.stale_pr_threshold_days or 14

    # Check if PR actually stale by user's threshold
    days_inactive = (datetime.utcnow() - pr.updated_at).days
    if days_inactive < threshold_days:
        return

    # Send via preferred channels
    for channel in prefs.notification_channels:
        if channel == "in_app":
            await create_in_app_notification(creator.id, {
                "type": "stale_pr",
                "pr_id": pr.id,
                "card_id": card.id,
                "days_inactive": days_inactive
            })
        elif channel == "email":
            await send_email_notification(creator.email, "stale_pr", {
                "pr_number": pr.number,
                "pr_title": pr.title,
                "card_title": card.title,
                "days_inactive": days_inactive
            })
```

**Board-Level Override:**

Workspace admins can disable stale PR notifications for entire board:

```python
# Board model extension
disable_stale_pr_notifications = Column(Boolean, default=False)
```

If board setting is disabled, no stale PR notifications sent regardless of user preferences.

**Testing Requirements:**
- Integration test: Branch deletion with retry on network error
- Integration test: Protected branch detection (wildcard patterns)
- Integration test: Stale PR notification respects user preferences
- Integration test: Bulk cleanup partial failure handling

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 3 Story 3.7 | Sarah (PO Agent) |
| 2025-10-23 | 1.1 | Added error recovery with retry logic, dynamic protected branch configuration, notification preferences | Bob (SM Agent) |
