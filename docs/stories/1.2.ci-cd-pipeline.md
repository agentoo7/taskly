# Story 1.2: CI/CD Pipeline & Initial Deployment

## Status
Draft

---

## Story

**As a** developer,
**I want** an automated CI/CD pipeline that runs tests and deploys to staging,
**so that** we can ship changes confidently with every merge.

---

## Acceptance Criteria

1. GitHub Actions workflow triggers on every pull request and push to main branch
2. CI pipeline runs: linting (ESLint, Ruff), type checking (TypeScript, mypy), formatting validation (Prettier, Black)
3. Build verification step confirms Docker images build successfully for both frontend and backend
4. Pull requests blocked from merging if CI checks fail
5. Successful merges to main automatically deploy to staging environment
6. Staging environment accessible at designated URL (e.g., `https://staging.taskly.app` or cloud provider URL)
7. Deployment status visible in GitHub Actions UI with clear success/failure indicators
8. Rollback mechanism documented (can redeploy previous commit if deployment fails)
9. Environment secrets managed via GitHub Secrets or cloud provider secrets manager (not in repository)
10. Deployment logs accessible for debugging failed deployments

---

## Tasks / Subtasks

- [ ] **Task 1: Create GitHub Actions CI workflow** (AC: 1, 2, 3, 4)
  - [ ] Create `.github/workflows/ci.yml` file
  - [ ] Configure trigger: on pull_request and push to main/dev branches
  - [ ] Add job: Lint Frontend (ESLint, Prettier check)
  - [ ] Add job: Lint Backend (Ruff, Black check)
  - [ ] Add job: Type Check Frontend (TypeScript compiler)
  - [ ] Add job: Type Check Backend (mypy)
  - [ ] Add job: Build Frontend Docker Image (verify build succeeds)
  - [ ] Add job: Build Backend Docker Image (verify build succeeds)
  - [ ] Configure branch protection rules to require CI passing before merge

- [ ] **Task 2: Add unit test execution to CI** (AC: 2)
  - [ ] Add job: Test Frontend (Vitest with coverage report)
  - [ ] Add job: Test Backend (pytest with coverage report)
  - [ ] Upload coverage reports as artifacts
  - [ ] Configure coverage thresholds (fail if <80%)
  - [ ] Add coverage badges to README (optional)

- [ ] **Task 3: Set up DigitalOcean infrastructure for staging** (AC: 5, 6, 9)
  - [ ] Create DigitalOcean account and project "Taskly"
  - [ ] Provision staging Droplet (2vCPU, 4GB RAM, Ubuntu 22.04)
  - [ ] Install Docker and Docker Compose on Droplet
  - [ ] Set up managed PostgreSQL database (Basic plan, single node)
  - [ ] Set up managed Redis cluster (Basic plan, single node)
  - [ ] Configure firewall: allow ports 22 (SSH), 80 (HTTP), 443 (HTTPS)
  - [ ] Set up DNS: point `staging.taskly.app` to Droplet IP (or use DO subdomain)
  - [ ] Store infrastructure credentials in GitHub Secrets: `DO_SSH_PRIVATE_KEY`, `DO_STAGING_HOST`

- [ ] **Task 4: Create deployment workflow** (AC: 5, 6, 7, 10)
  - [ ] Create `.github/workflows/deploy-staging.yml` file
  - [ ] Configure trigger: on push to main branch (after CI passes)
  - [ ] Add step: Build and tag Docker images with commit SHA
  - [ ] Add step: Push Docker images to DigitalOcean Container Registry or Docker Hub
  - [ ] Add step: SSH into staging Droplet
  - [ ] Add step: Pull latest Docker images on staging server
  - [ ] Add step: Run database migrations (Alembic upgrade head)
  - [ ] Add step: Restart services with `docker-compose up -d`
  - [ ] Add step: Run health check against staging API (`curl https://staging.taskly.app/api/health`)
  - [ ] Add step: Send deployment notification (GitHub commit status)
  - [ ] Configure deployment logs visible in GitHub Actions UI

- [ ] **Task 5: Configure environment secrets** (AC: 9)
  - [ ] Add GitHub Secrets for staging: `STAGING_DATABASE_URL`, `STAGING_REDIS_URL`, `STAGING_SECRET_KEY`, `STAGING_GITHUB_CLIENT_ID`, `STAGING_GITHUB_CLIENT_SECRET`
  - [ ] Create staging environment variables file on Droplet: `/opt/taskly/.env.staging`
  - [ ] Use GitHub Actions to sync secrets to Droplet during deployment
  - [ ] Verify secrets are never logged in CI/CD output (mask sensitive values)
  - [ ] Document secret rotation process in deployment docs

- [ ] **Task 6: Set up HTTPS with Let's Encrypt** (AC: 6)
  - [ ] Install Nginx on staging Droplet as reverse proxy
  - [ ] Configure Nginx to proxy `staging.taskly.app` to `localhost:3000` (frontend)
  - [ ] Configure Nginx to proxy `staging.taskly.app/api` to `localhost:8000` (backend)
  - [ ] Install Certbot and obtain Let's Encrypt SSL certificate
  - [ ] Configure Nginx SSL settings (TLS 1.3, modern cipher suite)
  - [ ] Set up automatic certificate renewal (cron job)
  - [ ] Verify HTTPS works: `curl https://staging.taskly.app/api/health`

- [ ] **Task 7: Document deployment and rollback procedures** (AC: 8, 10)
  - [ ] Create `docs/deployment.md` with deployment architecture diagram
  - [ ] Document staging environment setup steps
  - [ ] Document manual deployment procedure (if GitHub Actions fails)
  - [ ] Document rollback procedure: re-run workflow with previous commit SHA, or manually `git revert` and redeploy
  - [ ] Document how to access deployment logs: GitHub Actions UI and staging server `/var/log/`
  - [ ] Document common deployment failures and fixes (port conflicts, DB migration errors, secrets not synced)
  - [ ] Document health check troubleshooting

- [ ] **Task 8: Test complete CI/CD pipeline** (AC: 1-10)
  - [ ] Create test PR with intentional linting error, verify CI fails
  - [ ] Fix linting error, verify CI passes
  - [ ] Merge PR to main, verify deployment workflow triggers automatically
  - [ ] Verify staging environment updates with latest code
  - [ ] Test health check endpoint on staging: `https://staging.taskly.app/api/health`
  - [ ] Test rollback: revert commit, verify staging rolls back to previous version
  - [ ] Verify deployment logs accessible in GitHub Actions
  - [ ] Test secret management: rotate a secret, verify deployment picks up new value

---

## Dev Notes

### CI/CD Architecture

**Pipeline Stages:**
1. **Pull Request**: Lint → Type Check → Unit Tests → Build Images → Report Status
2. **Merge to Main**: All PR checks + Deploy to Staging → Health Check → Notify

**GitHub Actions Strategy:**
- Use matrix builds for parallel execution (frontend and backend jobs run concurrently)
- Cache dependencies (npm cache, UV cache) to speed up builds
- Use Docker layer caching for faster image builds
- Fail fast: stop pipeline on first error

### GitHub Actions Workflow Example (CI)

```yaml
# .github/workflows/ci.yml
name: CI

on:
  pull_request:
    branches: [main, dev]
  push:
    branches: [main, dev]

jobs:
  lint-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint
      - name: Check formatting with Prettier
        working-directory: ./frontend
        run: npm run format:check

  lint-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v1
        with:
          version: "0.1.18"
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        working-directory: ./backend
        run: uv sync
      - name: Run Ruff
        working-directory: ./backend
        run: uv run ruff check .
      - name: Check formatting with Black
        working-directory: ./backend
        run: uv run black --check .

  typecheck-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      - name: Type check
        working-directory: ./frontend
        run: npm run type-check

  typecheck-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v1
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        working-directory: ./backend
        run: uv sync
      - name: Run mypy
        working-directory: ./backend
        run: uv run mypy app/

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      - name: Run tests with coverage
        working-directory: ./frontend
        run: npm run test:coverage
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./frontend/coverage/coverage-final.json

  test-backend:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v1
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        working-directory: ./backend
        run: uv sync
      - name: Run tests with coverage
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql+asyncpg://test:test@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379/0
        run: uv run pytest --cov=app --cov-report=xml
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/coverage.xml

  build-images:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: false
          tags: taskly-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Build backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: false
          tags: taskly-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

### Deployment Workflow Example

```yaml
# .github/workflows/deploy-staging.yml
name: Deploy to Staging

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: registry.digitalocean.com
          username: ${{ secrets.DO_REGISTRY_TOKEN }}
          password: ${{ secrets.DO_REGISTRY_TOKEN }}

      - name: Build and push images
        run: |
          docker buildx build --platform linux/amd64 \
            -t registry.digitalocean.com/taskly/frontend:${{ github.sha }} \
            -t registry.digitalocean.com/taskly/frontend:latest \
            --push ./frontend
          docker buildx build --platform linux/amd64 \
            -t registry.digitalocean.com/taskly/backend:${{ github.sha }} \
            -t registry.digitalocean.com/taskly/backend:latest \
            --push ./backend

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: deploy
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/taskly
            docker-compose pull
            docker-compose up -d
            docker-compose exec -T backend alembic upgrade head
            sleep 10
            curl -f http://localhost:8000/api/health || exit 1

      - name: Notify deployment status
        if: always()
        run: |
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{"text":"Staging deployment ${{ job.status }}: ${{ github.sha }}"}'
```

### DigitalOcean Infrastructure Setup

**Staging Environment:**
- Droplet: Basic (2vCPU, 4GB RAM, 80GB SSD) - $24/month
- Managed PostgreSQL: Basic (1vCPU, 1GB RAM, 10GB storage) - $15/month
- Managed Redis: Basic (1GB RAM) - $15/month
- Container Registry: 500GB transfer included free
- Total: ~$54/month

**Production Environment (Future):**
- Scale up to 2x API Droplets (4vCPU, 8GB RAM each)
- 2x Celery Worker Droplets
- Load Balancer
- Larger managed DB/Redis
- Estimated: ~$200/month

### Nginx Configuration for Staging

```nginx
# /etc/nginx/sites-available/staging.taskly.app
server {
    listen 80;
    server_name staging.taskly.app;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name staging.taskly.app;

    ssl_certificate /etc/letsencrypt/live/staging.taskly.app/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/staging.taskly.app/privkey.pem;
    ssl_protocols TLSv1.3;
    ssl_prefer_server_ciphers off;

    # Frontend (Next.js)
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Backend API
    location /api {
        proxy_pass http://localhost:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket
    location /ws {
        proxy_pass http://localhost:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}
```

### Rollback Procedure

**Automated Rollback (Recommended):**
1. Identify last known good commit SHA from GitHub Actions history
2. Re-run deployment workflow with previous commit:
   ```bash
   git revert <bad-commit-sha>
   git push origin main
   # Deployment workflow auto-triggers
   ```

**Manual Rollback (Emergency):**
1. SSH into staging server: `ssh deploy@staging.taskly.app`
2. Navigate to app directory: `cd /opt/taskly`
3. Pull previous Docker images:
   ```bash
   docker pull registry.digitalocean.com/taskly/frontend:<previous-sha>
   docker pull registry.digitalocean.com/taskly/backend:<previous-sha>
   ```
4. Update docker-compose.yml to use previous tags
5. Restart: `docker-compose up -d`
6. Rollback database if needed: `docker-compose exec backend alembic downgrade -1`

### Secrets Management

**GitHub Secrets Required:**
- `DO_REGISTRY_TOKEN` - DigitalOcean Container Registry access token
- `STAGING_HOST` - Staging server IP or domain
- `STAGING_SSH_KEY` - SSH private key for deployment user
- `STAGING_DATABASE_URL` - Managed PostgreSQL connection string
- `STAGING_REDIS_URL` - Managed Redis connection string
- `STAGING_SECRET_KEY` - JWT signing key (generate with `openssl rand -hex 32`)
- `STAGING_GITHUB_CLIENT_ID` - GitHub OAuth app client ID
- `STAGING_GITHUB_CLIENT_SECRET` - GitHub OAuth app secret

**Secret Rotation Best Practices:**
- Rotate JWT secret every 90 days
- Rotate database credentials annually
- Rotate SSH keys annually
- Use GitHub Actions environments for approval gates on production deploys

### Branch Protection Rules

Configure in GitHub Settings → Branches → Add rule for `main`:
- ✅ Require pull request reviews before merging (1 approval)
- ✅ Require status checks to pass before merging
  - `lint-frontend`
  - `lint-backend`
  - `typecheck-frontend`
  - `typecheck-backend`
  - `test-frontend`
  - `test-backend`
  - `build-images`
- ✅ Require branches to be up to date before merging
- ✅ Include administrators (enforce rules for admins too)

### Testing

**CI Pipeline Testing:**
1. Create PR with linting violation → verify CI fails
2. Create PR with type error → verify CI fails
3. Create PR with failing test → verify CI fails
4. Create PR with all checks passing → verify merge allowed
5. Merge to main → verify deployment workflow triggers

**Deployment Testing:**
1. Deploy to staging → verify health check passes
2. Access `https://staging.taskly.app` → verify frontend loads
3. Access `https://staging.taskly.app/api/health` → verify API responds
4. Check deployment logs in GitHub Actions → verify no errors
5. Test rollback → verify previous version restored

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 1 Story 1.2 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
