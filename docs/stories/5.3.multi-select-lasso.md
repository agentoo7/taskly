# Story 5.3: Multi-Select & Lasso Selection

## Status
Draft

---

## Story

**As a** board member,
**I want** to select multiple cards at once for bulk operations,
**so that** I can efficiently manage large numbers of cards.

---

## Acceptance Criteria

1. Multi-select enabled in Kanban view: clicking checkbox icon in card corner (appears on hover) selects card
2. Selected cards display visual indicator: blue border, semi-transparent blue overlay, checkmark in corner
3. Shift+Click on card selects all cards between last selected card and clicked card (range selection)
4. Ctrl+Click (Cmd+Click on Mac) toggles individual card selection without affecting other selections
5. Lasso selection: Click and drag in empty board space draws selection rectangle; all cards overlapping rectangle when mouse released are selected
6. Lasso visual: semi-transparent blue rectangle with dashed border follows cursor during drag
7. Selection count displayed in floating toolbar at bottom of screen: "5 cards selected" with action buttons
8. Floating toolbar buttons: "Assign" (assignee dropdown), "Label" (label dropdown), "Priority" (priority dropdown), "Move to Column" (column dropdown), "Delete" (with confirmation), "Clear Selection"
9. Bulk actions apply to all selected cards in single API request (batch endpoint: `POST /api/cards/bulk-update` with card IDs array and update payload)
10. Bulk update optimistic: UI updates immediately for all selected cards, rollback if API fails with error toast showing failed count
11. Activity log entries for bulk actions: "[User] assigned 5 cards to [Username]", "[User] added label 'Bug' to 3 cards"
12. Select all button in board header: "Select All" checkbox selects all visible cards (respects active filters)
13. Indeterminate checkbox state: if some but not all cards selected, checkbox shows indeterminate state (dash icon)
14. Keyboard support: "A" selects all in focused column, Ctrl+A selects all visible on board, Shift+J/K extends selection up/down
15. Selection persists across view switches: selecting cards in Kanban then switching to Timeline preserves selection
16. Selection cleared on: Escape key, clicking "Clear Selection" button, performing destructive action like delete, leaving board (navigating away)
17. Mobile/tablet touch support: long-press card (500ms) enters multi-select mode with checkboxes appearing on all cards

---

## Tasks / Subtasks

- [ ] **Task 1: Add selection state management** (AC: 1, 2, 15, 16)
  - [ ] Add selection state to Zustand store
  - [ ] Track selected card IDs array
  - [ ] Clear selection on navigation
  - [ ] Persist across view switches

- [ ] **Task 2: Implement checkbox selection** (AC: 1, 2)
  - [ ] Add checkbox to card corner (visible on hover)
  - [ ] Toggle selection on checkbox click
  - [ ] Visual indicators: blue border, overlay, checkmark
  - [ ] Update selection state

- [ ] **Task 3: Add click modifier selection** (AC: 3, 4)
  - [ ] Shift+Click for range selection
  - [ ] Ctrl/Cmd+Click for individual toggle
  - [ ] Calculate range between cards
  - [ ] Handle cross-column ranges

- [ ] **Task 4: Implement lasso selection** (AC: 5, 6)
  - [ ] Detect mouse down in empty space
  - [ ] Draw selection rectangle during drag
  - [ ] Semi-transparent blue with dashed border
  - [ ] Calculate overlapping cards on mouse up
  - [ ] Update selection state

- [ ] **Task 5: Create floating toolbar** (AC: 7, 8)
  - [ ] Create `frontend/src/components/board/selection-toolbar.tsx`
  - [ ] Fixed position at bottom of screen
  - [ ] Show selection count
  - [ ] Action buttons: Assign, Label, Priority, Move, Delete, Clear

- [ ] **Task 6: Build bulk update API endpoint** (AC: 9, 10)
  - [ ] Create `POST /api/cards/bulk-update`
  - [ ] Accept card IDs array and update payload
  - [ ] Process in database transaction
  - [ ] Return success/failure for each card

- [ ] **Task 7: Implement optimistic updates** (AC: 10)
  - [ ] Update UI immediately on bulk action
  - [ ] Rollback on API failure
  - [ ] Show error toast with failed count
  - [ ] Re-fetch affected cards

- [ ] **Task 8: Add bulk activity logging** (AC: 11)
  - [ ] Create aggregated activity entries
  - [ ] Format: "[User] action X cards"
  - [ ] Log to activity timeline

- [ ] **Task 9: Add select all functionality** (AC: 12, 13, 14)
  - [ ] Add "Select All" checkbox to board header
  - [ ] Indeterminate state for partial selection
  - [ ] Keyboard shortcuts: A, Ctrl+A, Shift+J/K
  - [ ] Respect active filters

- [ ] **Task 10: Add mobile touch support** (AC: 17)
  - [ ] Detect long-press (500ms)
  - [ ] Enter multi-select mode
  - [ ] Show checkboxes on all cards
  - [ ] Touch-friendly toolbar

- [ ] **Task 11: Write tests** (AC: 1-17)
  - [ ] Unit test: Selection state management
  - [ ] Unit test: Range selection calculation
  - [ ] Component test: Lasso selection
  - [ ] Integration test: Bulk update API
  - [ ] E2E test: Full multi-select workflow

---

## Dev Notes

### Selection State Management

```typescript
// frontend/src/stores/selection-store.ts
import { create } from 'zustand'

interface SelectionStore {
  selectedCardIds: string[]
  lastSelectedId: string | null
  selectCard: (cardId: string) => void
  deselectCard: (cardId: string) => void
  toggleCard: (cardId: string) => void
  selectRange: (startId: string, endId: string, allCardIds: string[]) => void
  selectAll: (cardIds: string[]) => void
  clearSelection: () => void
}

export const useSelectionStore = create<SelectionStore>((set, get) => ({
  selectedCardIds: [],
  lastSelectedId: null,

  selectCard: (cardId) => {
    set((state) => ({
      selectedCardIds: [...state.selectedCardIds, cardId],
      lastSelectedId: cardId,
    }))
  },

  deselectCard: (cardId) => {
    set((state) => ({
      selectedCardIds: state.selectedCardIds.filter((id) => id !== cardId),
    }))
  },

  toggleCard: (cardId) => {
    const { selectedCardIds } = get()
    if (selectedCardIds.includes(cardId)) {
      get().deselectCard(cardId)
    } else {
      get().selectCard(cardId)
    }
  },

  selectRange: (startId, endId, allCardIds) => {
    const startIndex = allCardIds.indexOf(startId)
    const endIndex = allCardIds.indexOf(endId)

    if (startIndex === -1 || endIndex === -1) return

    const [min, max] = [Math.min(startIndex, endIndex), Math.max(startIndex, endIndex)]
    const rangeIds = allCardIds.slice(min, max + 1)

    set((state) => ({
      selectedCardIds: Array.from(new Set([...state.selectedCardIds, ...rangeIds])),
      lastSelectedId: endId,
    }))
  },

  selectAll: (cardIds) => {
    set({ selectedCardIds: cardIds, lastSelectedId: null })
  },

  clearSelection: () => {
    set({ selectedCardIds: [], lastSelectedId: null })
  },
}))
```

### Card Component with Selection

```typescript
// frontend/src/components/board/card.tsx
'use client'

import { useState } from 'react'
import { Checkbox } from '@/components/ui/checkbox'
import { useSelectionStore } from '@/stores/selection-store'
import { cn } from '@/lib/utils'

export function Card({ card, allCardIds }: any) {
  const [showCheckbox, setShowCheckbox] = useState(false)
  const { selectedCardIds, toggleCard, selectRange, lastSelectedId } = useSelectionStore()

  const isSelected = selectedCardIds.includes(card.id)

  const handleClick = (e: React.MouseEvent) => {
    if (e.shiftKey && lastSelectedId) {
      e.preventDefault()
      selectRange(lastSelectedId, card.id, allCardIds)
    } else if (e.ctrlKey || e.metaKey) {
      e.preventDefault()
      toggleCard(card.id)
    }
  }

  const handleCheckboxChange = (checked: boolean) => {
    toggleCard(card.id)
  }

  // Long-press for mobile
  const handleLongPress = () => {
    toggleCard(card.id)
  }

  return (
    <div
      className={cn(
        'relative rounded-lg border bg-card p-3 shadow-sm transition-all',
        isSelected && 'border-blue-500 bg-blue-50/50 dark:bg-blue-950/50'
      )}
      onMouseEnter={() => setShowCheckbox(true)}
      onMouseLeave={() => setShowCheckbox(false)}
      onClick={handleClick}
      onContextMenu={(e) => {
        e.preventDefault()
        handleLongPress()
      }}
    >
      {(showCheckbox || isSelected) && (
        <div className="absolute top-2 right-2">
          <Checkbox
            checked={isSelected}
            onCheckedChange={handleCheckboxChange}
            onClick={(e) => e.stopPropagation()}
          />
        </div>
      )}

      {isSelected && (
        <div className="absolute inset-0 bg-blue-500/10 rounded-lg pointer-events-none" />
      )}

      <div className="space-y-2">
        <h3 className="font-medium">{card.title}</h3>
        {/* Card content */}
      </div>
    </div>
  )
}
```

### Lasso Selection

```typescript
// frontend/src/components/board/lasso-selection.tsx
'use client'

import { useState, useRef } from 'react'
import { useSelectionStore } from '@/stores/selection-store'

interface Rectangle {
  startX: number
  startY: number
  endX: number
  endY: number
}

export function LassoSelection({ children, cards }: any) {
  const [isSelecting, setIsSelecting] = useState(false)
  const [rectangle, setRectangle] = useState<Rectangle | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const { selectAll } = useSelectionStore()

  const handleMouseDown = (e: React.MouseEvent) => {
    // Only start lasso on empty space
    if ((e.target as HTMLElement).closest('[data-card]')) return

    const rect = containerRef.current!.getBoundingClientRect()
    setIsSelecting(true)
    setRectangle({
      startX: e.clientX - rect.left,
      startY: e.clientY - rect.top,
      endX: e.clientX - rect.left,
      endY: e.clientY - rect.top,
    })
  }

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isSelecting || !rectangle) return

    const rect = containerRef.current!.getBoundingClientRect()
    setRectangle({
      ...rectangle,
      endX: e.clientX - rect.left,
      endY: e.clientY - rect.top,
    })
  }

  const handleMouseUp = () => {
    if (!isSelecting || !rectangle) return

    // Calculate overlapping cards
    const selectedCardIds = cards.filter((card: any) => {
      const cardEl = document.querySelector(`[data-card-id="${card.id}"]`)
      if (!cardEl) return false

      const cardRect = cardEl.getBoundingClientRect()
      const containerRect = containerRef.current!.getBoundingClientRect()

      const cardLeft = cardRect.left - containerRect.left
      const cardTop = cardRect.top - containerRect.top
      const cardRight = cardLeft + cardRect.width
      const cardBottom = cardTop + cardRect.height

      const selectionLeft = Math.min(rectangle.startX, rectangle.endX)
      const selectionTop = Math.min(rectangle.startY, rectangle.endY)
      const selectionRight = Math.max(rectangle.startX, rectangle.endX)
      const selectionBottom = Math.max(rectangle.startY, rectangle.endY)

      return !(
        cardRight < selectionLeft ||
        cardLeft > selectionRight ||
        cardBottom < selectionTop ||
        cardTop > selectionBottom
      )
    }).map((card: any) => card.id)

    selectAll(selectedCardIds)
    setIsSelecting(false)
    setRectangle(null)
  }

  return (
    <div
      ref={containerRef}
      className="relative"
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
    >
      {children}

      {isSelecting && rectangle && (
        <div
          className="absolute border-2 border-dashed border-blue-500 bg-blue-500/10 pointer-events-none"
          style={{
            left: Math.min(rectangle.startX, rectangle.endX),
            top: Math.min(rectangle.startY, rectangle.endY),
            width: Math.abs(rectangle.endX - rectangle.startX),
            height: Math.abs(rectangle.endY - rectangle.startY),
          }}
        />
      )}
    </div>
  )
}
```

### Selection Toolbar

```typescript
// frontend/src/components/board/selection-toolbar.tsx
'use client'

import { Button } from '@/components/ui/button'
import { useSelectionStore } from '@/stores/selection-store'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

export function SelectionToolbar({ boardId }: any) {
  const { selectedCardIds, clearSelection } = useSelectionStore()
  const queryClient = useQueryClient()

  const bulkUpdateMutation = useMutation({
    mutationFn: (payload: any) =>
      api.post('/api/cards/bulk-update', {
        card_ids: selectedCardIds,
        ...payload,
      }),
    onSuccess: (data) => {
      const successCount = data.success_count || selectedCardIds.length
      const failCount = selectedCardIds.length - successCount

      if (failCount > 0) {
        toast.error(`${failCount} cards failed to update`)
      } else {
        toast.success(`${successCount} cards updated`)
      }

      queryClient.invalidateQueries({ queryKey: ['board', boardId] })
      clearSelection()
    },
    onError: () => {
      toast.error('Failed to update cards')
    },
  })

  if (selectedCardIds.length === 0) return null

  return (
    <div className="fixed bottom-6 left-1/2 -translate-x-1/2 bg-background border rounded-lg shadow-lg p-4 z-50">
      <div className="flex items-center gap-4">
        <span className="text-sm font-medium">
          {selectedCardIds.length} card{selectedCardIds.length === 1 ? '' : 's'} selected
        </span>

        <div className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => {
              // Open assignee dropdown
            }}
          >
            Assign
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={() => {
              // Open label dropdown
            }}
          >
            Label
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={() => {
              // Open priority dropdown
            }}
          >
            Priority
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={() => {
              // Open column dropdown
            }}
          >
            Move
          </Button>

          <Button
            variant="destructive"
            size="sm"
            onClick={() => {
              if (confirm(`Delete ${selectedCardIds.length} cards?`)) {
                bulkUpdateMutation.mutate({ action: 'delete' })
              }
            }}
          >
            Delete
          </Button>

          <Button
            variant="ghost"
            size="sm"
            onClick={clearSelection}
          >
            Clear
          </Button>
        </div>
      </div>
    </div>
  )
}
```

### Bulk Update API Endpoint

```python
# backend/app/api/cards.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.models.card import Card
from app.models.activity import CardActivity, ActivityAction

router = APIRouter()

@router.post("/bulk-update")
async def bulk_update_cards(
    card_ids: list[UUID],
    assignee_ids: list[UUID] | None = None,
    label_ids: list[UUID] | None = None,
    priority: str | None = None,
    column_id: UUID | None = None,
    db: AsyncSession = Depends(get_db),
    current_user = Depends(get_current_user),
):
    """Bulk update multiple cards in a single transaction."""
    success_count = 0
    failed_cards = []

    async with db.begin():
        for card_id in card_ids:
            try:
                card = await db.get(Card, card_id)
                if not card:
                    failed_cards.append({"card_id": card_id, "error": "Not found"})
                    continue

                # Update fields
                if assignee_ids is not None:
                    card.assignees = [await db.get(User, uid) for uid in assignee_ids]
                if label_ids is not None:
                    card.labels = [await db.get(Label, lid) for lid in label_ids]
                if priority is not None:
                    card.priority = priority
                if column_id is not None:
                    card.column_id = column_id

                success_count += 1

            except Exception as e:
                failed_cards.append({"card_id": card_id, "error": str(e)})

        # Log activity
        if assignee_ids:
            CardActivity.create(
                card_id=card_ids[0],  # Representative
                action=ActivityAction.BULK_ASSIGNED,
                user_id=current_user.id,
                metadata={"count": success_count, "assignee_ids": assignee_ids}
            )

    return {
        "success_count": success_count,
        "failed_count": len(failed_cards),
        "failed_cards": failed_cards,
    }
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 5 Story 5.3 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
