# Story 2.2: Team Member Invitations & Permissions

## Status
Draft

---

## Story

**As a** workspace admin,
**I want** to invite team members via email and manage their permissions,
**so that** my team can collaborate on boards.

---

## Acceptance Criteria

1. Workspace settings page displays "Invite Members" button (visible to admins only)
2. Clicking button opens invite modal with email input field (supports multiple comma-separated emails)
3. Role selector dropdown offers two options: "Member" (default), "Admin"
4. Submitting invitation sends email to each address with invite link containing secure token
5. Email template includes: workspace name, inviter's name/avatar, "Join Workspace" CTA button, expiration notice (7 days)
6. Invite link redirects to Taskly; if recipient not logged in, prompts GitHub OAuth first, then accepts invite
7. Accepting invite adds user to workspace_members table with specified role and redirects to workspace dashboard
8. Workspace settings displays member list with columns: avatar, username, email, role, "Remove" button (for admins)
9. Admins can change member roles via dropdown in member list (member ↔ admin)
10. Admins can remove members from workspace (requires confirmation: "Remove [username] from workspace?")
11. Removed members lose access immediately; attempting to access workspace shows 403 error with message "You are no longer a member of this workspace"
12. Invite tokens expire after 7 days; expired links show error message "Invite expired. Please request a new invitation."
13. Members (non-admin role) can view workspace and boards but cannot invite others, change permissions, or delete workspace

---

## Tasks / Subtasks

- [ ] **Task 1: Create invitation data models** (AC: 4, 12)
  - [ ] Create `backend/app/models/workspace_invitation.py`
  - [ ] Define `WorkspaceInvitation` model: id, workspace_id, email, role, token, invited_by, created_at, expires_at, accepted_at
  - [ ] Generate secure random token (32 bytes, URL-safe)
  - [ ] Set expiration to 7 days from creation
  - [ ] Add unique constraint on (workspace_id, email) to prevent duplicate invites
  - [ ] Create Alembic migration for workspace_invitations table

- [ ] **Task 2: Create invitation API endpoints** (AC: 2, 3, 4, 6, 7, 12)
  - [ ] Implement `POST /workspaces/{id}/invitations` - create invitations (admin only)
  - [ ] Implement `GET /invitations/{token}` - get invitation details (public)
  - [ ] Implement `POST /invitations/{token}/accept` - accept invitation (authenticated)
  - [ ] Implement `DELETE /invitations/{id}` - revoke invitation (admin only)
  - [ ] Validate email format and role enum
  - [ ] Check invitation not expired before accepting
  - [ ] Add user to workspace_members on acceptance

- [ ] **Task 3: Create invitation service layer** (AC: 4, 5, 7, 12)
  - [ ] Create `backend/app/services/invitation_service.py`
  - [ ] Implement `create_invitations(workspace_id, emails, role, inviter_id)` - creates invitation records
  - [ ] Implement `send_invitation_email(invitation)` - enqueues email send job
  - [ ] Implement `accept_invitation(token, user_id)` - validates token, adds membership
  - [ ] Implement `revoke_invitation(invitation_id, admin_id)` - deletes invitation
  - [ ] Check invitation not already accepted
  - [ ] Check user not already workspace member before accepting

- [ ] **Task 4: Implement email sending with Celery** (AC: 4, 5)
  - [ ] Create Celery task: `backend/app/tasks/send_invitation_email.py`
  - [ ] Configure email provider (SendGrid, AWS SES, or SMTP for development)
  - [ ] Load email credentials from environment variables
  - [ ] Create HTML email template: `backend/app/templates/emails/workspace_invitation.html`
  - [ ] Include workspace name, inviter name/avatar, CTA button, expiration date
  - [ ] Generate invitation URL: `https://taskly.app/invitations/{token}`
  - [ ] Test email sending in development (use Mailhog or print to console)

- [ ] **Task 5: Create invite members modal** (AC: 1, 2, 3, 4)
  - [ ] Create `frontend/src/components/workspace/invite-members-modal.tsx`
  - [ ] Add email input field with tag input component (supports multiple emails)
  - [ ] Add role selector dropdown: Member (default), Admin
  - [ ] Validate email format for each entered email
  - [ ] Display entered emails as chips/tags with remove button
  - [ ] On submit, call `POST /workspaces/{id}/invitations` with emails array and role
  - [ ] Show success toast: "Invitations sent to X members"
  - [ ] Clear form and close modal on success

- [ ] **Task 6: Update workspace settings with invite button** (AC: 1)
  - [ ] Update `frontend/src/app/(dashboard)/workspaces/[workspaceId]/settings/page.tsx`
  - [ ] Add "Invite Members" button to header (visible to admins only)
  - [ ] Check current user's role from workspace members query
  - [ ] Open invite modal on button click
  - [ ] Pass workspace ID to modal

- [ ] **Task 7: Create invitation acceptance page** (AC: 6, 7, 12)
  - [ ] Create `frontend/src/app/invitations/[token]/page.tsx`
  - [ ] Fetch invitation details: `GET /invitations/{token}`
  - [ ] Display invitation preview: workspace name, inviter info, role
  - [ ] If user not authenticated, show "Sign in with GitHub to accept" button
  - [ ] After auth, call `POST /invitations/{token}/accept`
  - [ ] On success, redirect to workspace dashboard
  - [ ] Handle expired tokens: show error message with link to request new invitation
  - [ ] Handle already accepted invitations: redirect to workspace

- [ ] **Task 8: Create member list component** (AC: 8, 9, 10, 11, 13)
  - [ ] Create `frontend/src/components/workspace/member-list.tsx`
  - [ ] Fetch workspace members: `GET /workspaces/{id}/members`
  - [ ] Display table with columns: Avatar, Name, Email, Role, Actions
  - [ ] Show role badge (Admin/Member) with color coding
  - [ ] For admins, show role dropdown to change member role
  - [ ] For admins, show "Remove" button for each member (except self)
  - [ ] Implement optimistic updates for role changes
  - [ ] Open confirmation modal before removing member

- [ ] **Task 9: Implement role change functionality** (AC: 9)
  - [ ] Create API endpoint: `PATCH /workspaces/{id}/members/{user_id}`
  - [ ] Accept role in request body: `{"role": "admin" | "member"}`
  - [ ] Validate requesting user is admin
  - [ ] Update workspace_members.role in database
  - [ ] Broadcast WebSocket event: `member_role_changed`
  - [ ] Frontend invalidates members query on mutation success

- [ ] **Task 10: Implement member removal** (AC: 10, 11)
  - [ ] Create API endpoint: `DELETE /workspaces/{id}/members/{user_id}`
  - [ ] Validate requesting user is admin
  - [ ] Prevent admin from removing themselves
  - [ ] Delete workspace_members record
  - [ ] Broadcast WebSocket event: `member_removed`
  - [ ] Frontend shows confirmation modal before removal
  - [ ] On success, remove member from list and show toast

- [ ] **Task 11: Add permission checks to workspace access** (AC: 11, 13)
  - [ ] Update workspace middleware to check user is member
  - [ ] Return 403 error if user not in workspace_members table
  - [ ] Include helpful error message: "You are no longer a member of this workspace"
  - [ ] Non-admin members can view workspace but not access settings
  - [ ] Hide admin-only actions (invite, remove, delete) for regular members

- [ ] **Task 12: Add pending invitations list to settings** (AC: 4, 12)
  - [ ] Update workspace settings to show pending invitations section
  - [ ] Display table: Email, Role, Invited By, Invited At, Expires At, Actions
  - [ ] Show "Pending" badge for unaccepted invitations
  - [ ] Add "Revoke" button for each pending invitation (admins only)
  - [ ] Show expiration countdown: "Expires in 3 days"
  - [ ] Auto-refresh list when invitations accepted or revoked

- [ ] **Task 13: Write tests for invitations** (AC: 1-13)
  - [ ] Unit test: Generate secure invitation token
  - [ ] Unit test: Invitation expires after 7 days
  - [ ] Integration test: Create and send invitations
  - [ ] Integration test: Accept invitation adds user to workspace
  - [ ] Integration test: Expired invitation cannot be accepted
  - [ ] Integration test: Only admins can invite members
  - [ ] Integration test: Member removal revokes access
  - [ ] E2E test: Full invitation flow from send to acceptance

---

## Dev Notes

### Workspace Invitation Model

```python
# backend/app/models/workspace_invitation.py
import secrets
from datetime import datetime, timedelta
from sqlalchemy import Column, String, DateTime, ForeignKey, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
from app.core.database import Base
from app.models.workspace_member import RoleEnum

class WorkspaceInvitation(Base):
    __tablename__ = "workspace_invitations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    workspace_id = Column(UUID(as_uuid=True), ForeignKey("workspaces.id", ondelete="CASCADE"), nullable=False)
    email = Column(String(255), nullable=False)
    role = Column(SQLEnum(RoleEnum), nullable=False, default=RoleEnum.MEMBER)
    token = Column(String(64), unique=True, nullable=False, default=lambda: secrets.token_urlsafe(32))
    invited_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    expires_at = Column(DateTime(timezone=True), default=lambda: datetime.utcnow() + timedelta(days=7))
    accepted_at = Column(DateTime(timezone=True))

    # Relationships
    workspace = relationship("Workspace")
    inviter = relationship("User")

    # Unique constraint: one active invite per email per workspace
    __table_args__ = (
        UniqueConstraint('workspace_id', 'email', name='uq_workspace_email_invitation'),
    )

    @property
    def is_expired(self) -> bool:
        return datetime.utcnow() > self.expires_at

    @property
    def is_accepted(self) -> bool:
        return self.accepted_at is not None
```

### Invitation Service Implementation

```python
# backend/app/services/invitation_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from app.models.workspace_invitation import WorkspaceInvitation
from app.models.workspace_member import WorkspaceMember, RoleEnum
from app.models.workspace import Workspace
from app.models.user import User
from app.tasks.send_invitation_email import send_invitation_email_task
from fastapi import HTTPException, status
from uuid import UUID
from datetime import datetime

class InvitationService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def create_invitations(
        self,
        workspace_id: UUID,
        emails: list[str],
        role: RoleEnum,
        inviter_id: UUID
    ) -> list[WorkspaceInvitation]:
        """Create and send invitations to multiple emails."""
        # Verify inviter is admin
        await self._check_admin(workspace_id, inviter_id)

        invitations = []
        for email in emails:
            # Check if user already member
            existing_member = await self.db.execute(
                select(WorkspaceMember)
                .join(User)
                .where(
                    and_(
                        WorkspaceMember.workspace_id == workspace_id,
                        User.email == email.lower()
                    )
                )
            )
            if existing_member.scalar_one_or_none():
                continue  # Skip already-member emails

            # Check if invitation already exists
            existing_invite = await self.db.execute(
                select(WorkspaceInvitation).where(
                    and_(
                        WorkspaceInvitation.workspace_id == workspace_id,
                        WorkspaceInvitation.email == email.lower(),
                        WorkspaceInvitation.accepted_at.is_(None)
                    )
                )
            )
            if existing_invite.scalar_one_or_none():
                continue  # Skip if pending invitation exists

            # Create invitation
            invitation = WorkspaceInvitation(
                workspace_id=workspace_id,
                email=email.lower(),
                role=role,
                invited_by=inviter_id
            )
            self.db.add(invitation)
            invitations.append(invitation)

        await self.db.commit()

        # Send emails asynchronously
        for invitation in invitations:
            await self.db.refresh(invitation)
            send_invitation_email_task.delay(str(invitation.id))

        return invitations

    async def accept_invitation(self, token: str, user_id: UUID) -> WorkspaceMember:
        """Accept invitation and add user to workspace."""
        # Find invitation
        result = await self.db.execute(
            select(WorkspaceInvitation).where(WorkspaceInvitation.token == token)
        )
        invitation = result.scalar_one_or_none()

        if not invitation:
            raise HTTPException(status_code=404, detail="Invitation not found")

        if invitation.is_expired:
            raise HTTPException(status_code=400, detail="Invitation has expired")

        if invitation.is_accepted:
            raise HTTPException(status_code=400, detail="Invitation already accepted")

        # Get user
        user = await self.db.get(User, user_id)
        if user.email.lower() != invitation.email.lower():
            raise HTTPException(
                status_code=403,
                detail="This invitation is for a different email address"
            )

        # Check if user already member
        existing = await self.db.execute(
            select(WorkspaceMember).where(
                and_(
                    WorkspaceMember.workspace_id == invitation.workspace_id,
                    WorkspaceMember.user_id == user_id
                )
            )
        )
        if existing.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="Already a workspace member")

        # Add user to workspace
        member = WorkspaceMember(
            workspace_id=invitation.workspace_id,
            user_id=user_id,
            role=invitation.role
        )
        self.db.add(member)

        # Mark invitation as accepted
        invitation.accepted_at = datetime.utcnow()

        await self.db.commit()
        await self.db.refresh(member)

        return member

    async def _check_admin(self, workspace_id: UUID, user_id: UUID):
        """Verify user is workspace admin."""
        result = await self.db.execute(
            select(WorkspaceMember).where(
                and_(
                    WorkspaceMember.workspace_id == workspace_id,
                    WorkspaceMember.user_id == user_id,
                    WorkspaceMember.role == RoleEnum.ADMIN
                )
            )
        )
        if not result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Must be workspace admin"
            )
```

### Email Template (HTML)

```html
<!-- backend/app/templates/emails/workspace_invitation.html -->
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; margin-bottom: 30px; }
    .logo { font-size: 24px; font-weight: bold; color: #0366D6; }
    .content { background: #f6f8fa; padding: 30px; border-radius: 8px; }
    .avatar { width: 48px; height: 48px; border-radius: 50%; }
    .button { display: inline-block; background: #0366D6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
    .footer { text-align: center; margin-top: 30px; color: #586069; font-size: 12px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">Taskly</div>
    </div>
    <div class="content">
      <h2>You've been invited to join {{ workspace_name }}</h2>
      <p>
        <img src="{{ inviter_avatar }}" class="avatar" alt="{{ inviter_name }}">
        <strong>{{ inviter_name }}</strong> invited you to collaborate in the <strong>{{ workspace_name }}</strong> workspace on Taskly.
      </p>
      <p>You've been invited as a <strong>{{ role }}</strong>.</p>
      <div style="text-align: center;">
        <a href="{{ invitation_url }}" class="button">Join Workspace</a>
      </div>
      <p style="font-size: 14px; color: #586069;">
        This invitation expires in 7 days on {{ expires_at }}.
      </p>
    </div>
    <div class="footer">
      <p>If you weren't expecting this invitation, you can safely ignore this email.</p>
      <p>© {{ year }} Taskly. All rights reserved.</p>
    </div>
  </div>
</body>
</html>
```

### Celery Email Task

```python
# backend/app/tasks/send_invitation_email.py
from celery import shared_task
from app.core.database import AsyncSessionLocal
from app.models.workspace_invitation import WorkspaceInvitation
from sqlalchemy import select
import os
from jinja2 import Environment, FileSystemLoader

@shared_task
def send_invitation_email_task(invitation_id: str):
    """Send invitation email via email provider."""
    import asyncio
    asyncio.run(_send_email(invitation_id))

async def _send_email(invitation_id: str):
    async with AsyncSessionLocal() as db:
        result = await db.execute(
            select(WorkspaceInvitation).where(WorkspaceInvitation.id == invitation_id)
        )
        invitation = result.scalar_one_or_none()

        if not invitation:
            return

        # Load email template
        env = Environment(loader=FileSystemLoader('app/templates/emails'))
        template = env.get_template('workspace_invitation.html')

        html_content = template.render(
            workspace_name=invitation.workspace.name,
            inviter_name=invitation.inviter.username,
            inviter_avatar=invitation.inviter.avatar_url,
            role=invitation.role.value.title(),
            invitation_url=f"{os.getenv('APP_URL')}/invitations/{invitation.token}",
            expires_at=invitation.expires_at.strftime('%B %d, %Y'),
            year=datetime.now().year
        )

        # Send email (use SendGrid, AWS SES, or SMTP)
        # For development, print to console
        print(f"Sending invitation email to {invitation.email}")
        print(html_content)

        # Production: Use email provider SDK
        # await send_email_via_provider(invitation.email, html_content)
```

### Frontend Invite Members Modal

```typescript
// frontend/src/components/workspace/invite-members-modal.tsx
'use client'

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { X } from 'lucide-react'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

interface InviteMembersModalProps {
  workspaceId: string
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function InviteMembersModal({ workspaceId, open, onOpenChange }: InviteMembersModalProps) {
  const [emailInput, setEmailInput] = useState('')
  const [emails, setEmails] = useState<string[]>([])
  const [role, setRole] = useState<'member' | 'admin'>('member')
  const queryClient = useQueryClient()

  const inviteMutation = useMutation({
    mutationFn: (data: { emails: string[]; role: string }) =>
      api.post(`/workspaces/${workspaceId}/invitations`, data),
    onSuccess: () => {
      toast.success(`Invitations sent to ${emails.length} member(s)`)
      queryClient.invalidateQueries({ queryKey: ['workspace-members', workspaceId] })
      queryClient.invalidateQueries({ queryKey: ['workspace-invitations', workspaceId] })
      setEmails([])
      setEmailInput('')
      onOpenChange(false)
    },
    onError: () => {
      toast.error('Failed to send invitations')
    },
  })

  const addEmail = () => {
    const trimmed = emailInput.trim().toLowerCase()
    if (!trimmed) return

    // Simple email validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed)) {
      toast.error('Invalid email address')
      return
    }

    if (emails.includes(trimmed)) {
      toast.error('Email already added')
      return
    }

    setEmails([...emails, trimmed])
    setEmailInput('')
  }

  const removeEmail = (email: string) => {
    setEmails(emails.filter((e) => e !== email))
  }

  const handleSubmit = () => {
    if (emails.length === 0) {
      toast.error('Add at least one email address')
      return
    }
    inviteMutation.mutate({ emails, role })
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Invite Team Members</DialogTitle>
          <DialogDescription>
            Invite people to collaborate in this workspace. They'll receive an email invitation.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid gap-2">
            <Label htmlFor="email">Email Addresses</Label>
            <div className="flex gap-2">
              <Input
                id="email"
                type="email"
                placeholder="member@example.com"
                value={emailInput}
                onChange={(e) => setEmailInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault()
                    addEmail()
                  }
                }}
              />
              <Button type="button" onClick={addEmail}>Add</Button>
            </div>
            {emails.length > 0 && (
              <div className="flex flex-wrap gap-2 mt-2">
                {emails.map((email) => (
                  <Badge key={email} variant="secondary" className="flex items-center gap-1">
                    {email}
                    <X
                      className="h-3 w-3 cursor-pointer"
                      onClick={() => removeEmail(email)}
                    />
                  </Badge>
                ))}
              </div>
            )}
          </div>
          <div className="grid gap-2">
            <Label htmlFor="role">Role</Label>
            <Select value={role} onValueChange={(value: any) => setRole(value)}>
              <SelectTrigger>
                <SelectValue placeholder="Select role" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="member">Member</SelectItem>
                <SelectItem value="admin">Admin</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-sm text-muted-foreground">
              {role === 'admin'
                ? 'Admins can invite members, manage settings, and delete the workspace.'
                : 'Members can view and edit boards but cannot manage workspace settings.'}
            </p>
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleSubmit} disabled={inviteMutation.isPending || emails.length === 0}>
            {inviteMutation.isPending ? 'Sending...' : `Send ${emails.length} Invitation(s)`}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

### Testing

**Integration Test - Invitation Flow:**
```python
# backend/tests/integration/test_invitations.py
@pytest.mark.asyncio
async def test_create_and_accept_invitation(client, test_workspace, admin_user, test_user):
    # Admin creates invitation
    response = await client.post(
        f"/workspaces/{test_workspace.id}/invitations",
        json={"emails": ["newuser@example.com"], "role": "member"},
        headers=auth_headers(admin_user)
    )
    assert response.status_code == 201
    data = response.json()
    token = data[0]["token"]

    # Accept invitation
    response = await client.post(
        f"/invitations/{token}/accept",
        headers=auth_headers(test_user)
    )
    assert response.status_code == 200

    # Verify membership
    response = await client.get(
        f"/workspaces/{test_workspace.id}/members",
        headers=auth_headers(test_user)
    )
    assert response.status_code == 200
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 2 Story 2.2 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
