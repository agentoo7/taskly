# Story 4.3: Sprint Burndown Chart

## Status
Draft

---

## Story

**As a** team lead,
**I want** to see a sprint burndown chart,
**so that** I can track progress and identify if we're on track to complete the sprint.

---

## Acceptance Criteria

1. Sprint detail view displays burndown chart: line graph showing remaining story points over time
2. X-axis shows sprint days (Day 1 to Day N), Y-axis shows story points
3. Ideal burndown line (straight line from total points to zero) shown as dashed gray line
4. Actual burndown line shows actual remaining points, updated when cards move to "Done"
5. Burndown recalculated daily via Celery periodic task (runs at midnight UTC)
6. Chart data stored in `sprint_burndown` table: sprint_id, date, remaining_points, completed_points
7. Chart shows current progress indicator: "On Track" (green), "Behind" (yellow), "Ahead" (blue)
8. Hovering over data point shows tooltip: "Day 5: 18 points remaining"
9. Chart responsive: full width on desktop, scrollable on mobile
10. Export chart as PNG image via "Export" button

---

## Tasks / Subtasks

- [ ] **Task 1: Create sprint_burndown table** (AC: 6)
  - [ ] Fields: id, sprint_id, date, remaining_points, completed_points, created_at
  - [ ] Create migration

- [ ] **Task 2: Implement daily burndown calculation** (AC: 5, 6)
  - [ ] Celery periodic task runs daily at midnight
  - [ ] Calculate remaining points (cards not in "Done" column)
  - [ ] Store in sprint_burndown table

- [ ] **Task 3: Create burndown chart component** (AC: 1, 2, 3, 4, 8, 9)
  - [ ] Use recharts or chart.js library
  - [ ] Plot ideal vs actual burndown
  - [ ] Responsive design
  - [ ] Tooltip on hover

- [ ] **Task 4: Add progress indicator** (AC: 7)
  - [ ] Compare actual vs ideal at current day
  - [ ] Show status: On Track, Behind, Ahead

- [ ] **Task 5: Implement chart export** (AC: 10)
  - [ ] Use html2canvas to capture chart as PNG
  - [ ] Download file

- [ ] **Task 6: Write tests** (AC: 1-10)
  - [ ] Unit test: Burndown calculation
  - [ ] Integration test: Daily task creates burndown record

---

## Dev Notes

### Burndown Calculation with Backfill Strategy

```python
from datetime import date, datetime, timedelta

@shared_task
def calculate_daily_burndown():
    """Calculate burndown for all active sprints."""
    active_sprints = Sprint.query.filter_by(status='active').all()

    for sprint in active_sprints:
        today = date.today()

        # Check if burndown record already exists for today (idempotent)
        existing = SprintBurndown.query.filter_by(
            sprint_id=sprint.id,
            date=today
        ).first()

        if existing:
            logger.info(f"Burndown for sprint {sprint.id} already calculated today")
            continue

        # Calculate remaining and completed points
        cards = Card.query.filter_by(sprint_id=sprint.id).all()
        done_column_ids = get_done_column_ids(sprint.board_id)

        remaining_points = sum(
            c.story_points or 0
            for c in cards
            if c.column_id not in done_column_ids
        )
        completed_points = sum(
            c.story_points or 0
            for c in cards
            if c.column_id in done_column_ids
        )

        SprintBurndown.create(
            sprint_id=sprint.id,
            date=today,
            remaining_points=remaining_points,
            completed_points=completed_points
        )
```

### Backfill Strategy

**Problem 1:** Sprint started 3 days ago, burndown feature deployed today - missing historical data.

**Problem 2:** Celery task failed for 2 days - data gap in chart.

**Solution: Manual Backfill Endpoint + Automatic Gap Detection**

**1. Manual Backfill Endpoint (Admin Only):**

```python
@router.post("/api/sprints/{sprint_id}/burndown/backfill")
async def backfill_sprint_burndown(
    sprint_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Backfill missing burndown data for sprint.
    Reconstructs historical data from card activity log.
    """
    # Authorization: Only workspace admin or sprint creator
    sprint = await db.get(Sprint, sprint_id)
    if not await is_workspace_admin(current_user.id, sprint.board.workspace_id):
        raise HTTPException(403, "Admin access required")

    # Get sprint date range
    start_date = sprint.start_date
    end_date = min(sprint.end_date, date.today())

    backfilled_days = []

    for day_offset in range((end_date - start_date).days + 1):
        current_date = start_date + timedelta(days=day_offset)

        # Skip if already exists
        existing = await db.execute(
            select(SprintBurndown).where(
                SprintBurndown.sprint_id == sprint_id,
                SprintBurndown.date == current_date
            )
        )
        if existing.scalar_one_or_none():
            continue

        # Reconstruct points at end of this day
        remaining, completed = await reconstruct_burndown_at_date(
            sprint_id, current_date, db
        )

        # Create burndown record
        burndown = SprintBurndown(
            sprint_id=sprint_id,
            date=current_date,
            remaining_points=remaining,
            completed_points=completed
        )
        db.add(burndown)
        backfilled_days.append(current_date)

    await db.commit()

    return {
        "message": f"Backfilled {len(backfilled_days)} days",
        "dates": [str(d) for d in backfilled_days]
    }


async def reconstruct_burndown_at_date(
    sprint_id: UUID,
    target_date: date,
    db: AsyncSession
) -> tuple[int, int]:
    """
    Reconstruct remaining/completed points at end of target_date.
    Uses card activity log to determine state.
    """
    sprint = await db.get(Sprint, sprint_id)
    cards = await db.execute(
        select(Card).where(Card.sprint_id == sprint_id)
    )
    cards = cards.scalars().all()

    done_column_ids = await get_done_column_ids(sprint.board_id)

    remaining_points = 0
    completed_points = 0

    for card in cards:
        points = card.story_points or 0

        # Check card activity log: was card in "Done" column by end of target_date?
        was_done = await was_card_done_on_date(card.id, target_date, done_column_ids, db)

        if was_done:
            completed_points += points
        else:
            remaining_points += points

    return remaining_points, completed_points


async def was_card_done_on_date(
    card_id: UUID,
    target_date: date,
    done_column_ids: list[UUID],
    db: AsyncSession
) -> bool:
    """Check if card was in 'Done' column by end of target_date."""
    # Query activity log for most recent column move before/on target_date
    result = await db.execute(
        select(CardActivity)
        .where(
            CardActivity.card_id == card_id,
            CardActivity.action == "moved",
            func.date(CardActivity.created_at) <= target_date
        )
        .order_by(CardActivity.created_at.desc())
        .limit(1)
    )
    last_move = result.scalar_one_or_none()

    if not last_move:
        # No moves by target_date, check card's original column
        card = await db.get(Card, card_id)
        return card.column_id in done_column_ids

    # Check if last move was to Done column
    move_data = last_move.metadata
    return move_data.get("new_column_id") in [str(cid) for cid in done_column_ids]
```

**2. Automatic Gap Detection:**

```python
@shared_task
def detect_and_fill_burndown_gaps():
    """Detect missing burndown days and fill gaps automatically."""
    active_sprints = Sprint.query.filter_by(status='active').all()

    for sprint in active_sprints:
        # Find gaps in burndown data
        start_date = sprint.start_date
        end_date = min(sprint.end_date, date.today())

        existing_dates = set(
            bd.date for bd in SprintBurndown.query.filter_by(sprint_id=sprint.id).all()
        )

        all_dates = {
            start_date + timedelta(days=i)
            for i in range((end_date - start_date).days + 1)
        }

        missing_dates = all_dates - existing_dates

        if missing_dates:
            logger.warning(f"Sprint {sprint.id} missing burndown for {len(missing_dates)} days")
            # Auto-fill gaps (same logic as backfill)
            for missing_date in sorted(missing_dates):
                remaining, completed = reconstruct_burndown_at_date(sprint.id, missing_date)
                SprintBurndown.create(
                    sprint_id=sprint.id,
                    date=missing_date,
                    remaining_points=remaining,
                    completed_points=completed
                )
            logger.info(f"Auto-filled {len(missing_dates)} missing burndown days for sprint {sprint.id}")
```

### Weekend/Holiday Handling

**Problem:** Should burndown continue on weekends? What about holidays?

**Solution: Configurable Weekend Behavior + Holiday Calendar**

**Workspace Settings:**

```python
class Workspace(Base):
    # ... existing fields ...
    burndown_include_weekends = Column(Boolean, default=True)
    # True: Burndown continues on weekends (ideal line doesn't pause)
    # False: Burndown pauses on weekends (ideal line steps)

    burndown_holiday_calendar = Column(JSONB, default=list)
    # List of holiday dates: ["2025-12-25", "2025-01-01"]
```

**Burndown Ideal Line Calculation:**

```python
def calculate_ideal_burndown(sprint: Sprint) -> list[dict]:
    """Calculate ideal burndown line respecting weekends/holidays."""
    start_date = sprint.start_date
    end_date = sprint.end_date
    total_points = sprint.capacity_points

    # Get workspace settings
    include_weekends = sprint.board.workspace.burndown_include_weekends
    holidays = set(sprint.board.workspace.burndown_holiday_calendar or [])

    # Count working days
    working_days = 0
    current = start_date
    while current <= end_date:
        is_weekend = current.weekday() >= 5  # Saturday=5, Sunday=6
        is_holiday = str(current) in holidays

        if include_weekends or (not is_weekend and not is_holiday):
            working_days += 1

        current += timedelta(days=1)

    # Calculate daily burn rate
    if working_days == 0:
        daily_burn = 0
    else:
        daily_burn = total_points / working_days

    # Generate ideal line
    ideal_line = []
    remaining = total_points
    current = start_date

    while current <= end_date:
        is_weekend = current.weekday() >= 5
        is_holiday = str(current) in holidays

        # Burn points on working days only (if weekends excluded)
        if include_weekends or (not is_weekend and not is_holiday):
            ideal_line.append({
                "date": str(current),
                "remaining_points": max(0, remaining),
                "is_working_day": True
            })
            remaining -= daily_burn
        else:
            # Non-working day: ideal line stays flat
            prev_remaining = ideal_line[-1]["remaining_points"] if ideal_line else total_points
            ideal_line.append({
                "date": str(current),
                "remaining_points": prev_remaining,
                "is_working_day": False
            })

        current += timedelta(days=1)

    return ideal_line
```

**UI for Weekend/Holiday Settings:**

```
Workspace Settings → Sprint & Burndown

☑ Include weekends in burndown chart
   When enabled, ideal line continues on weekends.
   When disabled, ideal line pauses on Sat/Sun.

Holidays (burndown pauses on these dates):
┌────────────────────────┐
│ 2025-12-25 Christmas   │ [×]
│ 2025-01-01 New Year    │ [×]
│ [+ Add Holiday]        │
└────────────────────────┘
```

**Chart Display:**

```
Sprint Burndown Chart

[Chart showing]:
- Blue dashed line: Ideal burndown (steps flat on weekends if excluded)
- Green solid line: Actual burndown
- Gray vertical bars: Weekends/holidays (if excluded)

Legend:
━━━ Actual  ┅┅┅ Ideal  ▓ Non-working days
```

**Testing Requirements:**
- Integration test: Backfill burndown for sprint started 5 days ago
- Integration test: Automatic gap detection fills missing 2-day period
- Unit test: Ideal line calculation with weekends excluded
- Unit test: Ideal line calculation with holidays

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 4 Story 4.3 | Sarah (PO Agent) |
| 2025-10-23 | 1.1 | Added backfill strategy (manual endpoint + auto gap detection), weekend/holiday handling, activity log reconstruction | Bob (SM Agent) |
