# Story 4.1: Sprint Creation & Planning

## Status
Draft

---

## Story

**As a** product owner,
**I want** to create sprints and assign cards to them,
**so that** I can plan work in time-boxed iterations.

---

## Acceptance Criteria

1. Board sidebar displays "Sprints" section with list of sprints: Active (green), Planned (blue), Completed (gray)
2. "+ New Sprint" button opens sprint creation modal with fields: name, start date, end date, goal (optional text, max 500 chars), capacity (story points)
3. Sprint dates validated: end date must be after start date, no overlapping sprints on same board
4. Creating sprint adds to `sprints` table and displays in sprint list
5. Sprint status auto-calculated from dates: "Planned" (future), "Active" (current), "Completed" (past)
6. Clicking sprint in sidebar filters board to show only cards in that sprint
7. Card detail modal includes "Sprint" dropdown selector showing all sprints (Planned + Active only, not Completed)
8. Assigning card to sprint updates `cards.sprint_id` field
9. Sprint view shows sprint header: name, dates, goal, progress bar (completed points / total points)
10. Dragging card from backlog to sprint view assigns card to sprint automatically
11. Sprint capacity warning: if total story points exceed capacity, show yellow warning icon with tooltip
12. Board filter allows filtering by: "Current Sprint", "Backlog (No Sprint)", "All Sprints"
13. Completing sprint requires confirmation: "Mark sprint as complete? This will archive the sprint."
14. Completed sprints become read-only, cards can be moved to new sprint or backlog

---

## Tasks / Subtasks

- [ ] **Task 1: Verify Sprint model** (AC: 4)
  - [ ] Check `backend/app/models/sprint.py` exists (created in Story 1.3)
  - [ ] Fields: id, board_id, name, start_date, end_date, goal, capacity_points, status, created_at, updated_at, deleted_at
  - [ ] Status enum: planned, active, completed

- [ ] **Task 2: Create sprint API endpoints** (AC: 2, 3, 4, 13)
  - [ ] Implement `POST /boards/{id}/sprints` - create new sprint
  - [ ] Implement `GET /boards/{id}/sprints` - list board sprints
  - [ ] Implement `GET /sprints/{id}` - get sprint with cards
  - [ ] Implement `PATCH /sprints/{id}` - update sprint (name, dates, goal)
  - [ ] Implement `POST /sprints/{id}/complete` - mark sprint as complete
  - [ ] Implement `DELETE /sprints/{id}` - delete sprint (planned only)

- [ ] **Task 3: Create sprint service layer** (AC: 3, 5, 13)
  - [ ] Create `backend/app/services/sprint_service.py`
  - [ ] Implement `create_sprint(board_id, name, start_date, end_date, goal, capacity)`
  - [ ] Validate no overlapping sprints (same board, date ranges overlap)
  - [ ] Auto-calculate status from dates
  - [ ] Implement `complete_sprint(sprint_id)` - sets deleted_at timestamp (soft delete)

- [ ] **Task 4: Create sprint creation modal** (AC: 2, 3)
  - [ ] Create `frontend/src/components/sprint/create-sprint-modal.tsx`
  - [ ] Form fields: name (required), start/end date pickers, goal textarea, capacity number input
  - [ ] Validate dates: end > start, warn if overlaps with existing sprint
  - [ ] Default capacity: 40 story points
  - [ ] On submit, call `POST /boards/{id}/sprints`

- [ ] **Task 5: Add sprints section to board sidebar** (AC: 1, 6)
  - [ ] Update board sidebar with "Sprints" section
  - [ ] Fetch sprints: `GET /boards/{id}/sprints`
  - [ ] Group by status: Active, Planned, Completed
  - [ ] Status indicators: colored dots (green/blue/gray)
  - [ ] Clicking sprint filters board to show sprint cards only
  - [ ] Add "+ New Sprint" button

- [ ] **Task 6: Add sprint selector to card detail modal** (AC: 7, 8)
  - [ ] Add "Sprint" field in card metadata section
  - [ ] Dropdown shows Planned + Active sprints
  - [ ] "Backlog" option (sets sprint_id to null)
  - [ ] On change, call `PATCH /cards/{id}` with sprint_id
  - [ ] Optimistic update with rollback

- [ ] **Task 7: Create sprint view page** (AC: 9, 10)
  - [ ] Create `frontend/src/app/(dashboard)/workspaces/[workspaceId]/boards/[boardId]/sprints/[sprintId]/page.tsx`
  - [ ] Display sprint header with name, dates, goal
  - [ ] Show progress bar: completed points / total points
  - [ ] Render board columns filtered to sprint cards
  - [ ] Support drag-and-drop from backlog section

- [ ] **Task 8: Implement sprint capacity warning** (AC: 11)
  - [ ] Calculate total story points in sprint
  - [ ] Compare to sprint.capacity_points
  - [ ] If exceeded, show warning icon in sprint header
  - [ ] Tooltip: "Sprint is over capacity by X points"
  - [ ] Color-coded: green (<80%), yellow (80-100%), red (>100%)

- [ ] **Task 9: Add sprint filters to board** (AC: 12)
  - [ ] Update board filter bar with sprint filter
  - [ ] Options: "Current Sprint", "Backlog", "All Sprints", "Select Sprint..."
  - [ ] Filter cards client-side by sprint_id
  - [ ] Persist filter in URL query params

- [ ] **Task 10: Implement sprint completion** (AC: 13, 14)
  - [ ] Add "Complete Sprint" button to sprint view (if status = active)
  - [ ] Confirmation modal: "Mark sprint as complete?"
  - [ ] Call `POST /sprints/{id}/complete`
  - [ ] Soft delete sprint (set deleted_at)
  - [ ] Sprint becomes read-only
  - [ ] Cards can be moved to new sprint via bulk action

- [ ] **Task 11: Write tests for sprint management** (AC: 1-14)
  - [ ] Unit test: Sprint date validation (no overlaps)
  - [ ] Unit test: Sprint status calculation
  - [ ] Integration test: Create sprint API
  - [ ] Integration test: Assign cards to sprint
  - [ ] Integration test: Complete sprint
  - [ ] Component test: Sprint creation modal
  - [ ] E2E test: Full sprint planning workflow

---

## Dev Notes

### Sprint Model

```python
# backend/app/models/sprint.py
import enum
from datetime import datetime, date
from sqlalchemy import Column, String, Text, Integer, Date, DateTime, ForeignKey, Enum as SQLEnum, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
from app.core.database import Base

class SprintStatus(str, enum.Enum):
    PLANNED = "planned"
    ACTIVE = "active"
    COMPLETED = "completed"

class Sprint(Base):
    __tablename__ = "sprints"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    board_id = Column(UUID(as_uuid=True), ForeignKey("boards.id", ondelete="CASCADE"), nullable=False)
    name = Column(String(100), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    goal = Column(Text)
    capacity_points = Column(Integer, default=40)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    deleted_at = Column(DateTime(timezone=True))  # Soft delete for completed sprints

    # Relationships
    board = relationship("Board", back_populates="sprints")
    cards = relationship("Card", back_populates="sprint")

    @property
    def status(self) -> SprintStatus:
        """Calculate sprint status from dates."""
        today = date.today()
        if self.deleted_at:
            return SprintStatus.COMPLETED
        if today < self.start_date:
            return SprintStatus.PLANNED
        elif self.start_date <= today <= self.end_date:
            return SprintStatus.ACTIVE
        else:
            return SprintStatus.COMPLETED

    @property
    def duration_days(self) -> int:
        return (self.end_date - self.start_date).days
```

### Sprint Service Implementation

```python
# backend/app/services/sprint_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from app.models.sprint import Sprint, SprintStatus
from app.models.board import Board
from datetime import date
from fastapi import HTTPException

class SprintService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def create_sprint(
        self,
        board_id: UUID,
        name: str,
        start_date: date,
        end_date: date,
        goal: str = None,
        capacity_points: int = 40
    ) -> Sprint:
        """Create new sprint with date validation."""
        # Validate dates
        if end_date <= start_date:
            raise HTTPException(status_code=400, detail="End date must be after start date")

        # Check for overlapping sprints
        overlapping = await self.db.execute(
            select(Sprint).where(
                and_(
                    Sprint.board_id == board_id,
                    Sprint.deleted_at.is_(None),
                    or_(
                        and_(Sprint.start_date <= start_date, Sprint.end_date >= start_date),
                        and_(Sprint.start_date <= end_date, Sprint.end_date >= end_date),
                        and_(Sprint.start_date >= start_date, Sprint.end_date <= end_date)
                    )
                )
            )
        )
        if overlapping.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="Sprint dates overlap with existing sprint")

        # Create sprint
        sprint = Sprint(
            board_id=board_id,
            name=name,
            start_date=start_date,
            end_date=end_date,
            goal=goal,
            capacity_points=capacity_points
        )
        self.db.add(sprint)
        await self.db.commit()
        await self.db.refresh(sprint)
        return sprint

    async def complete_sprint(self, sprint_id: UUID) -> Sprint:
        """Mark sprint as complete (soft delete)."""
        sprint = await self.db.get(Sprint, sprint_id)
        if not sprint:
            raise HTTPException(status_code=404, detail="Sprint not found")

        sprint.deleted_at = datetime.utcnow()
        await self.db.commit()
        await self.db.refresh(sprint)
        return sprint

    async def get_sprint_stats(self, sprint_id: UUID) -> dict:
        """Calculate sprint statistics."""
        sprint = await self.db.get(Sprint, sprint_id)
        cards = await self.db.execute(
            select(Card).where(Card.sprint_id == sprint_id)
        )
        cards = cards.scalars().all()

        total_points = sum(card.story_points or 0 for card in cards)
        completed_points = sum(
            card.story_points or 0
            for card in cards
            if card.column_id in self._get_done_columns(sprint.board)
        )

        return {
            "total_points": total_points,
            "completed_points": completed_points,
            "capacity": sprint.capacity_points,
            "card_count": len(cards),
            "progress_percent": (completed_points / total_points * 100) if total_points > 0 else 0
        }
```

### Frontend Sprint Creation Modal

```typescript
// frontend/src/components/sprint/create-sprint-modal.tsx
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import * as z from 'zod'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Calendar } from '@/components/ui/calendar'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { CalendarIcon } from 'lucide-react'
import { format } from 'date-fns'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

const schema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  start_date: z.date(),
  end_date: z.date(),
  goal: z.string().max(500).optional(),
  capacity_points: z.number().min(0).max(999),
}).refine(data => data.end_date > data.start_date, {
  message: "End date must be after start date",
  path: ["end_date"],
})

export function CreateSprintModal({ boardId, open, onOpenChange }: any) {
  const queryClient = useQueryClient()

  const { register, handleSubmit, formState: { errors }, setValue, watch } = useForm({
    resolver: zodResolver(schema),
    defaultValues: {
      capacity_points: 40,
    }
  })

  const startDate = watch('start_date')
  const endDate = watch('end_date')

  const createMutation = useMutation({
    mutationFn: (data: any) => api.post(`/boards/${boardId}/sprints`, {
      ...data,
      start_date: format(data.start_date, 'yyyy-MM-dd'),
      end_date: format(data.end_date, 'yyyy-MM-dd'),
    }),
    onSuccess: () => {
      toast.success('Sprint created')
      queryClient.invalidateQueries({ queryKey: ['board-sprints', boardId] })
      onOpenChange(false)
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to create sprint')
    },
  })

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Create Sprint</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit((data) => createMutation.mutate(data))}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label>Sprint Name</Label>
              <Input {...register('name')} placeholder="Sprint 1" />
              {errors.name && <p className="text-sm text-destructive">{errors.name.message}</p>}
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="grid gap-2">
                <Label>Start Date</Label>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button variant="outline" className="justify-start">
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {startDate ? format(startDate, 'MMM dd, yyyy') : 'Select date'}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent>
                    <Calendar
                      mode="single"
                      selected={startDate}
                      onSelect={(date) => setValue('start_date', date!)}
                    />
                  </PopoverContent>
                </Popover>
              </div>

              <div className="grid gap-2">
                <Label>End Date</Label>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button variant="outline" className="justify-start">
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {endDate ? format(endDate, 'MMM dd, yyyy') : 'Select date'}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent>
                    <Calendar
                      mode="single"
                      selected={endDate}
                      onSelect={(date) => setValue('end_date', date!)}
                    />
                  </PopoverContent>
                </Popover>
                {errors.end_date && <p className="text-sm text-destructive">{errors.end_date.message}</p>}
              </div>
            </div>

            <div className="grid gap-2">
              <Label>Sprint Goal (Optional)</Label>
              <Textarea
                {...register('goal')}
                placeholder="What do we want to achieve in this sprint?"
                rows={3}
              />
            </div>

            <div className="grid gap-2">
              <Label>Capacity (Story Points)</Label>
              <Input
                type="number"
                {...register('capacity_points', { valueAsNumber: true })}
                min="0"
                max="999"
              />
            </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={createMutation.isPending}>
              {createMutation.isPending ? 'Creating...' : 'Create Sprint'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

### Testing

**Unit Test - Sprint Validation:**
```python
@pytest.mark.asyncio
async def test_create_sprint_validates_dates(db_session, test_board):
    service = SprintService(db_session)

    # Test end date before start date
    with pytest.raises(HTTPException) as exc:
        await service.create_sprint(
            test_board.id,
            "Sprint 1",
            start_date=date(2025, 2, 1),
            end_date=date(2025, 1, 15)
        )
    assert exc.value.status_code == 400
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 4 Story 4.1 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
