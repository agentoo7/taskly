# Story 5.2: Keyboard Navigation & Shortcuts

## Status
Draft

---

## Story

**As a** power user,
**I want** comprehensive keyboard shortcuts for common actions,
**so that** I can navigate and manipulate boards without touching my mouse.

---

## Acceptance Criteria

1. Card navigation shortcuts: "J" moves focus to next card, "K" moves to previous card (Gmail-style), Tab cycles through cards in column order
2. Focused card indicated with blue outline border; pressing Enter opens card detail modal
3. Card manipulation: "E" edits focused card (opens detail modal), "D" deletes card (with confirmation), "M" opens move menu (arrow keys select column, Enter confirms)
4. Column navigation: Ctrl+← moves focus to previous column, Ctrl+→ moves to next column
5. Card creation: "C" opens quick-create input in currently focused column (or first column if no focus)
6. Multi-select: Shift+↑/↓ extends selection to adjacent cards, Ctrl+Click (or Cmd+Click on Mac) adds individual card to selection
7. Selection actions: "A" selects all cards in focused column, Ctrl+A selects all visible cards on board, Escape clears selection
8. View switching: "V" cycles through views (Kanban → Timeline → Kanban), "1" forces Kanban view, "2" forces Timeline view
9. Search: "/" activates board-wide search input (same as clicking search box), Escape closes search and clears filters
10. Undo/Redo: Ctrl+Z undoes last action (card move, edit, delete), Ctrl+Shift+Z redoes undone action (session-based, not persistent)
11. Global shortcuts work across entire app: "G then D" navigates to Dashboard, "G then S" navigates to Settings (Gmail-style sequential shortcuts)
12. Modal shortcuts: Enter submits form in modals (Create Board, Create Sprint), Escape closes modal without saving
13. Timeline-specific: Left/Right arrow keys pan timeline horizontally, "+"/"-" zoom in/out timeline density
14. Shortcut help overlay: pressing "?" displays cheat sheet modal showing all available shortcuts organized by category
15. Shortcuts configurable: Settings page "Keyboard Shortcuts" section allows remapping any shortcut (prevents conflicts, shows warning if duplicate)
16. Shortcuts respect focus context: text input fields disable navigation shortcuts (J/K/C/etc.) to prevent interference with typing; Escape re-enables
17. Visual feedback: when shortcut triggered, brief animation or highlight confirms action (e.g., "C" pressed → column highlight flash before quick-create appears)

---

## Tasks / Subtasks

- [ ] **Task 1: Create keyboard shortcut system** (AC: 1-9, 16, 17)
  - [ ] Create `frontend/src/lib/keyboard/shortcuts.ts`
  - [ ] Define shortcut registry with key bindings
  - [ ] Implement context-aware shortcut handling
  - [ ] Disable shortcuts when input fields focused
  - [ ] Add visual feedback for shortcut actions

- [ ] **Task 2: Implement card navigation** (AC: 1, 2, 4)
  - [ ] Add focus state management to board cards
  - [ ] J/K navigation between cards
  - [ ] Tab to cycle through cards
  - [ ] Ctrl+Arrow for column navigation
  - [ ] Blue outline for focused card
  - [ ] Enter to open card detail

- [ ] **Task 3: Add card manipulation shortcuts** (AC: 3, 5)
  - [ ] E to edit focused card
  - [ ] D to delete with confirmation
  - [ ] M to open move menu
  - [ ] C to create card in focused column
  - [ ] Arrow key navigation in move menu

- [ ] **Task 4: Implement multi-select shortcuts** (AC: 6, 7)
  - [ ] Shift+Arrow to extend selection
  - [ ] Ctrl/Cmd+Click for individual selection
  - [ ] A to select all in column
  - [ ] Ctrl+A to select all visible
  - [ ] Escape to clear selection

- [ ] **Task 5: Add view and search shortcuts** (AC: 8, 9)
  - [ ] V to cycle views
  - [ ] 1/2 to force specific views
  - [ ] / to activate search
  - [ ] Escape to close search

- [ ] **Task 6: Implement undo/redo** (AC: 10)
  - [ ] Create undo stack in Zustand store
  - [ ] Track card moves, edits, deletes
  - [ ] Ctrl+Z to undo
  - [ ] Ctrl+Shift+Z to redo
  - [ ] Session-based (not persistent)

- [ ] **Task 7: Add global sequential shortcuts** (AC: 11)
  - [ ] Implement "G then X" pattern
  - [ ] G+D for dashboard
  - [ ] G+S for settings
  - [ ] Show pending key indicator

- [ ] **Task 8: Handle modal shortcuts** (AC: 12)
  - [ ] Enter to submit forms
  - [ ] Escape to close modals
  - [ ] Prevent event bubbling

- [ ] **Task 9: Add timeline-specific shortcuts** (AC: 13)
  - [ ] Left/Right arrow to pan
  - [ ] +/- to zoom
  - [ ] Only active in timeline view

- [ ] **Task 10: Create shortcut help overlay** (AC: 14)
  - [ ] Create `frontend/src/components/keyboard/shortcut-help.tsx`
  - [ ] Triggered by "?" key
  - [ ] Show all shortcuts grouped by category
  - [ ] Scrollable modal with search

- [ ] **Task 11: Build shortcut configuration UI** (AC: 15)
  - [ ] Add "Keyboard Shortcuts" section to settings
  - [ ] List all configurable shortcuts
  - [ ] Allow remapping with conflict detection
  - [ ] Store in user preferences
  - [ ] Apply custom shortcuts

- [ ] **Task 12: Write tests** (AC: 1-17)
  - [ ] Unit test: Shortcut registry
  - [ ] Unit test: Context detection
  - [ ] Component test: Card navigation
  - [ ] Component test: Undo/redo stack
  - [ ] E2E test: Full keyboard workflow

---

## Dev Notes

### Keyboard Shortcut System

```typescript
// frontend/src/lib/keyboard/shortcuts.ts
export interface Shortcut {
  key: string
  modifiers?: ('ctrl' | 'shift' | 'alt' | 'meta')[]
  description: string
  category: string
  action: (context: ShortcutContext) => void
  isEnabled?: (context: ShortcutContext) => boolean
}

export interface ShortcutContext {
  focusedCardId?: string
  focusedColumnId?: string
  selectedCardIds: string[]
  currentView: 'kanban' | 'timeline'
  isInputFocused: boolean
}

export const shortcuts: Shortcut[] = [
  // Navigation
  {
    key: 'j',
    description: 'Focus next card',
    category: 'Navigation',
    action: (ctx) => focusNextCard(ctx),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: 'k',
    description: 'Focus previous card',
    category: 'Navigation',
    action: (ctx) => focusPreviousCard(ctx),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: 'ArrowRight',
    modifiers: ['ctrl'],
    description: 'Focus next column',
    category: 'Navigation',
    action: (ctx) => focusNextColumn(ctx),
  },
  {
    key: 'ArrowLeft',
    modifiers: ['ctrl'],
    description: 'Focus previous column',
    category: 'Navigation',
    action: (ctx) => focusPreviousColumn(ctx),
  },

  // Card Actions
  {
    key: 'c',
    description: 'Create card',
    category: 'Card Actions',
    action: (ctx) => openQuickCreate(ctx),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: 'e',
    description: 'Edit focused card',
    category: 'Card Actions',
    action: (ctx) => openCardDetail(ctx.focusedCardId!),
    isEnabled: (ctx) => !ctx.isInputFocused && !!ctx.focusedCardId,
  },
  {
    key: 'd',
    description: 'Delete focused card',
    category: 'Card Actions',
    action: (ctx) => deleteCard(ctx.focusedCardId!),
    isEnabled: (ctx) => !ctx.isInputFocused && !!ctx.focusedCardId,
  },
  {
    key: 'm',
    description: 'Move focused card',
    category: 'Card Actions',
    action: (ctx) => openMoveMenu(ctx.focusedCardId!),
    isEnabled: (ctx) => !ctx.isInputFocused && !!ctx.focusedCardId,
  },

  // Selection
  {
    key: 'a',
    description: 'Select all in column',
    category: 'Selection',
    action: (ctx) => selectAllInColumn(ctx),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: 'a',
    modifiers: ['ctrl'],
    description: 'Select all visible cards',
    category: 'Selection',
    action: (ctx) => selectAllVisible(ctx),
  },
  {
    key: 'Escape',
    description: 'Clear selection',
    category: 'Selection',
    action: (ctx) => clearSelection(ctx),
  },

  // View Controls
  {
    key: 'v',
    description: 'Cycle views',
    category: 'View Controls',
    action: (ctx) => cycleView(ctx),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: '1',
    description: 'Kanban view',
    category: 'View Controls',
    action: (ctx) => switchView('kanban'),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },
  {
    key: '2',
    description: 'Timeline view',
    category: 'View Controls',
    action: (ctx) => switchView('timeline'),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },

  // Search
  {
    key: '/',
    description: 'Activate search',
    category: 'Search',
    action: (ctx) => activateSearch(),
    isEnabled: (ctx) => !ctx.isInputFocused,
  },

  // Undo/Redo
  {
    key: 'z',
    modifiers: ['ctrl'],
    description: 'Undo',
    category: 'Edit',
    action: (ctx) => undo(),
  },
  {
    key: 'z',
    modifiers: ['ctrl', 'shift'],
    description: 'Redo',
    category: 'Edit',
    action: (ctx) => redo(),
  },
]
```

### Keyboard Event Handler

```typescript
// frontend/src/hooks/use-keyboard-shortcuts.ts
'use client'

import { useEffect } from 'react'
import { shortcuts, ShortcutContext } from '@/lib/keyboard/shortcuts'

export function useKeyboardShortcuts(context: ShortcutContext) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check if input is focused
      const isInputFocused = ['INPUT', 'TEXTAREA'].includes(
        (e.target as HTMLElement).tagName
      )

      const updatedContext = { ...context, isInputFocused }

      // Find matching shortcut
      const shortcut = shortcuts.find((s) => {
        // Match key
        if (e.key !== s.key) return false

        // Match modifiers
        const hasCtrl = s.modifiers?.includes('ctrl') ?? false
        const hasShift = s.modifiers?.includes('shift') ?? false
        const hasAlt = s.modifiers?.includes('alt') ?? false
        const hasMeta = s.modifiers?.includes('meta') ?? false

        if (hasCtrl !== (e.ctrlKey || e.metaKey)) return false
        if (hasShift !== e.shiftKey) return false
        if (hasAlt !== e.altKey) return false
        if (hasMeta !== e.metaKey) return false

        // Check if enabled
        if (s.isEnabled && !s.isEnabled(updatedContext)) return false

        return true
      })

      if (shortcut) {
        e.preventDefault()
        shortcut.action(updatedContext)
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [context])
}
```

### Undo/Redo Stack

```typescript
// frontend/src/stores/undo-store.ts
import { create } from 'zustand'

interface UndoAction {
  type: 'move' | 'edit' | 'delete' | 'create'
  cardId: string
  before: any
  after: any
  execute: () => Promise<void>
  rollback: () => Promise<void>
}

interface UndoStore {
  undoStack: UndoAction[]
  redoStack: UndoAction[]
  addAction: (action: UndoAction) => void
  undo: () => Promise<void>
  redo: () => Promise<void>
  clearStacks: () => void
}

export const useUndoStore = create<UndoStore>((set, get) => ({
  undoStack: [],
  redoStack: [],

  addAction: (action) => {
    set((state) => ({
      undoStack: [...state.undoStack, action],
      redoStack: [], // Clear redo stack on new action
    }))
  },

  undo: async () => {
    const { undoStack, redoStack } = get()
    if (undoStack.length === 0) return

    const action = undoStack[undoStack.length - 1]
    await action.rollback()

    set({
      undoStack: undoStack.slice(0, -1),
      redoStack: [...redoStack, action],
    })
  },

  redo: async () => {
    const { undoStack, redoStack } = get()
    if (redoStack.length === 0) return

    const action = redoStack[redoStack.length - 1]
    await action.execute()

    set({
      undoStack: [...undoStack, action],
      redoStack: redoStack.slice(0, -1),
    })
  },

  clearStacks: () => set({ undoStack: [], redoStack: [] }),
}))
```

### Sequential Shortcuts (G+X Pattern)

```typescript
// frontend/src/hooks/use-sequential-shortcuts.ts
'use client'

import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'

export function useSequentialShortcuts() {
  const router = useRouter()
  const [pendingKey, setPendingKey] = useState<string | null>(null)

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const isInputFocused = ['INPUT', 'TEXTAREA'].includes(
        (e.target as HTMLElement).tagName
      )

      if (isInputFocused) return

      if (e.key === 'g' && !pendingKey) {
        e.preventDefault()
        setPendingKey('g')
        // Auto-clear after 2 seconds
        setTimeout(() => setPendingKey(null), 2000)
        return
      }

      if (pendingKey === 'g') {
        e.preventDefault()
        setPendingKey(null)

        if (e.key === 'd') {
          router.push('/dashboard')
        } else if (e.key === 's') {
          router.push('/settings')
        }
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [pendingKey, router])

  return { pendingKey }
}
```

### Shortcut Help Modal

```typescript
// frontend/src/components/keyboard/shortcut-help.tsx
'use client'

import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { shortcuts } from '@/lib/keyboard/shortcuts'

export function ShortcutHelpModal({ open, onOpenChange }: any) {
  // Group shortcuts by category
  const grouped = shortcuts.reduce((acc, shortcut) => {
    if (!acc[shortcut.category]) acc[shortcut.category] = []
    acc[shortcut.category].push(shortcut)
    return acc
  }, {} as Record<string, typeof shortcuts>)

  const formatShortcut = (shortcut: any) => {
    const keys = [...(shortcut.modifiers || []), shortcut.key]
    return keys.map((key) => {
      const display = {
        ctrl: '⌃',
        shift: '⇧',
        alt: '⌥',
        meta: '⌘',
      }[key] || key.toUpperCase()
      return <kbd key={key} className="px-2 py-1 text-xs bg-muted rounded">{display}</kbd>
    })
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-[600px] max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Keyboard Shortcuts</DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {Object.entries(grouped).map(([category, categoryShortcuts]) => (
            <div key={category}>
              <h3 className="text-sm font-semibold mb-2">{category}</h3>
              <div className="space-y-1">
                {categoryShortcuts.map((shortcut, idx) => (
                  <div key={idx} className="flex items-center justify-between py-1">
                    <span className="text-sm text-muted-foreground">
                      {shortcut.description}
                    </span>
                    <div className="flex gap-1">
                      {formatShortcut(shortcut)}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 5 Story 5.2 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
