# Story 3.5: Auto-Column Movement (PR Events)

## Status
Draft

---

## Story

**As a** developer,
**I want** cards to automatically move to "Done" when PRs are merged,
**so that** my board stays synchronized with code progress without manual updates.

---

## Acceptance Criteria

1. When PR linked to card is merged, card auto-moves to "Done" column (or last column if no "Done" column exists)
2. Auto-move only happens if card currently in "In Progress" or "In Review" columns (not from "To Do" or already "Done")
3. Auto-move adds activity entry: "[User] merged PR #123, moved card to Done"
4. Auto-move triggers WebSocket broadcast so all viewers see change in real-time
5. Board settings allow disabling auto-move with toggle: "Auto-move cards when PR merged"
6. Auto-move respects column mapping: board settings map PR states to columns (e.g., "PR Opened" → "In Progress", "PR Merged" → "Done")
7. If multiple PRs linked to card, auto-move only triggers when ALL PRs merged
8. Auto-move creates notification for card assignees: "Card moved to Done (PR #123 merged)"
9. User can undo auto-move within 30 seconds via toast notification "Undo" button
10. Undo reverts card to previous column and logs activity: "undid auto-move"

---

## Tasks / Subtasks

- [ ] **Task 1: Add auto-move settings to Board model** (AC: 5, 6)
  - [ ] Add `auto_move_enabled` boolean to boards table
  - [ ] Add `column_mapping` JSONB for PR state → column mapping
  - [ ] Default mapping: `{"pr_merged": "Done", "pr_opened": "In Progress"}`

- [ ] **Task 2: Implement auto-move logic** (AC: 1, 2, 7)
  - [ ] Create `backend/app/services/auto_move_service.py`
  - [ ] Method: `auto_move_on_pr_merge(card_id, pr_id)`
  - [ ] Check auto-move enabled on board
  - [ ] Check card in eligible column (In Progress, In Review)
  - [ ] If multiple PRs, check all merged before moving

- [ ] **Task 3: Trigger auto-move from webhook** (AC: 3, 4, 8)
  - [ ] In PR merge webhook handler, call auto-move service
  - [ ] Log activity with PR number and user
  - [ ] Broadcast WebSocket event
  - [ ] Create notifications for assignees

- [ ] **Task 4: Add board settings UI** (AC: 5, 6)
  - [ ] Add auto-move toggle to board settings
  - [ ] Add column mapping editor (advanced)
  - [ ] Save settings to database

- [ ] **Task 5: Implement undo functionality** (AC: 9, 10)
  - [ ] Store previous column in undo state (Zustand)
  - [ ] Show toast with "Undo" button for 30 seconds
  - [ ] Undo API endpoint moves card back

- [ ] **Task 6: Write tests** (AC: 1-10)
  - [ ] Unit test: Auto-move logic with multiple PRs
  - [ ] Integration test: Webhook triggers auto-move
  - [ ] E2E test: Card moves when PR merged

---

## Dev Notes

### Auto-Move Service

```python
# backend/app/services/auto_move_service.py
from sqlalchemy import select
from sqlalchemy.orm import selectinload

async def auto_move_on_pr_merge(card_id: UUID, pr_id: UUID, merged_by_user_id: UUID):
    """
    Auto-move card to Done when PR merged.
    Uses database transactions with READ COMMITTED isolation to prevent conflicts.
    """
    # Use transaction with explicit isolation level
    async with db.begin():  # READ COMMITTED isolation (PostgreSQL default)
        # Fetch card with row-level lock to prevent concurrent modifications
        result = await db.execute(
            select(Card)
            .where(Card.id == card_id)
            .with_for_update()  # SELECT ... FOR UPDATE locks row
            .options(selectinload(Card.board))
        )
        card = result.scalar_one()
        board = card.board

        if not board.auto_move_enabled:
            return

        # Check all linked PRs
        prs = await get_card_prs(card_id)
        if not all(pr.state == "merged" for pr in prs):
            return  # Wait until all PRs merged

        # Find "Done" column
        done_column = next((col for col in board.columns if col["name"].lower() == "done"), None)
        if not done_column:
            done_column = board.columns[-1]  # Use last column

        # Check if already in Done column (idempotent)
        if card.column_id == done_column["id"]:
            logger.info(f"Card {card_id} already in Done column, skipping auto-move")
            return

        # Move card with conflict check
        previous_column_id = card.column_id
        card.column_id = done_column["id"]
        card.position = 0  # Top of Done column
        card.updated_at = datetime.utcnow()

        await db.flush()  # Persist changes within transaction

        # Log activity with previous column for undo
        await log_activity(
            card_id,
            merged_by_user_id,
            "auto_moved",
            {
                "reason": "pr_merged",
                "pr_id": str(pr_id),
                "previous_column_id": str(previous_column_id),
                "new_column_id": str(done_column["id"])
            }
        )

        # Broadcast WebSocket event
        await broadcast_card_moved(card_id, done_column["id"])

    # Transaction committed automatically on context exit
```

### Conflict Resolution Strategy

**Scenario: User manually moves card while auto-move triggers simultaneously**

**Solution: Last-Write-Wins with Timestamp Ordering + Row-Level Locking**

1. **Database Transaction Isolation:** `READ COMMITTED` with row-level locking (`SELECT ... FOR UPDATE`)
   - First operation acquires lock on card row
   - Second operation waits for lock release
   - Prevents race conditions at database level

2. **Conflict Detection:**
   - Auto-move checks if `card.updated_at` changed since webhook triggered
   - If manual move happened first (newer `updated_at`), auto-move is skipped
   - Activity log shows both events for audit trail

3. **Idempotency Check:**
   - Auto-move checks if card already in target column before moving
   - If card manually moved to "Done" before auto-move, operation is no-op
   - Prevents duplicate activity entries

**Conflict Resolution Examples:**

| Event Sequence | Winner | Result | Rationale |
|----------------|--------|--------|-----------|
| Manual move → Auto-move (1s later) | Manual move | Card stays in manually selected column | Auto-move detects newer timestamp, skips |
| Auto-move → Manual move (1s later) | Manual move | Card in manually selected column | User intent takes precedence |
| Auto-move (multiple webhooks) → Auto-move | First auto-move | Card in Done column | Idempotency check prevents duplicate |

### Multiple PR Aggregation Logic

**Problem:** Card linked to multiple PRs - when does auto-move trigger?

**Rule:** Auto-move only when **ALL** linked PRs are merged.

**Algorithm:**

```python
async def should_auto_move(card_id: UUID) -> bool:
    """Check if card ready for auto-move (all PRs merged)."""
    prs = await db.execute(
        select(PullRequest).where(
            PullRequest.card_id == card_id,
            PullRequest.state != "merged"  # Any non-merged PR blocks auto-move
        )
    )
    non_merged_prs = prs.scalars().all()

    return len(non_merged_prs) == 0  # Auto-move only if all merged
```

**Examples:**

- Card has 1 PR → Auto-move when that PR merged
- Card has 2 PRs → Auto-move only when BOTH merged
- Card has 3 PRs, 2 merged → Wait until 3rd PR merged
- Card has PR #1 (merged), then links PR #2 (open) → Card stays in current column until PR #2 merged

**Edge Case Handling:**

| Scenario | Behavior |
|----------|----------|
| Card has no PRs linked | No auto-move triggered (nothing to detect) |
| Card already in "Done", new PR merged | No move (idempotency check) |
| One PR merged, second PR closed (not merged) | No auto-move (only merged PRs count) |
| All PRs merged, then new PR linked | Auto-move does NOT re-trigger (only on PR merge events) |

**User can disable this behavior** by setting `board.auto_move_enabled = false` in board settings.

### Transaction Isolation & Performance

**Database Transaction Settings:**

- **Isolation Level:** `READ COMMITTED` (PostgreSQL default)
  - Reads only committed data from other transactions
  - Prevents dirty reads
  - Allows concurrent reads, blocks concurrent writes on same row

- **Row-Level Locking:** `SELECT ... FOR UPDATE`
  - Locks card row during transaction
  - Other transactions wait for lock release (max 5 seconds timeout)
  - Prevents lost updates

- **Deadlock Prevention:**
  - Auto-move operations lock in consistent order (card → PRs → activity)
  - If deadlock detected, transaction retried (max 3 retries)
  - Celery task marks as failed after retries exhausted

**Performance Considerations:**

- Lock hold time: <100ms (typical transaction duration)
- Concurrent auto-moves on different cards: No contention (different rows)
- Concurrent manual move + auto-move on same card: Sequential (lock blocks)
- WebSocket broadcast happens after transaction commit (prevents partial state broadcast)

**Testing Requirements:**
- Integration test: Manual move + auto-move race condition
- Integration test: Multiple PR aggregation (2 PRs, both must merge)
- Load test: 50 concurrent auto-moves on different cards

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 3 Story 3.5 | Sarah (PO Agent) |
| 2025-10-23 | 1.1 | Added conflict resolution strategy, multiple PR aggregation logic, transaction isolation details | Bob (SM Agent) |
