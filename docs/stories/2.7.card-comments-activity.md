# Story 2.7: Card Comments & Activity Timeline

## Status
Draft

---

## Story

**As a** board member,
**I want** to add comments to cards and view activity history,
**so that** I can collaborate with my team and track card changes.

---

## Acceptance Criteria

1. Card detail modal displays "Comments & Activity" section below card metadata
2. Comment input box with "Add Comment" button (markdown supported, same editor as description)
3. Posting comment creates `CardComment` record with text, author, timestamp and displays in timeline
4. Comments display author avatar, name, timestamp ("2 hours ago"), and markdown-rendered text
5. Comment authors can edit their own comments via "Edit" button (inline edit mode)
6. Comment authors can delete their own comments via "Delete" button (requires confirmation: "Delete this comment?")
7. Activity timeline shows all card events: created, title changed, moved, assigned, label added, due date set, etc.
8. Activity entries auto-generated from database triggers or service layer, stored in `card_activity` table
9. Activity entries display: user avatar, action description ("Alice moved this card from To Do to In Progress"), timestamp
10. Timeline sorted by timestamp descending (newest first), combined comments and activities
11. Timeline paginated: load 20 items initially, "Load More" button fetches next 20
12. Real-time updates: new comments/activities appear immediately for all viewers via WebSocket without page refresh
13. @mention support in comments: typing "@alice" shows autocomplete dropdown of workspace members
14. @mentioned users receive notification (bell icon in navigation shows unread count)
15. Notification list shows: card title, comment snippet, author, timestamp; clicking navigates to card

---

## Tasks / Subtasks

- [ ] **Task 1: Create comment and activity database models** (AC: 3, 8)
  - [ ] Create `backend/app/models/card_comment.py`
  - [ ] Define `CardComment`: id, card_id, user_id, text (markdown), created_at, updated_at, deleted_at (soft delete)
  - [ ] Add relationships: `card`, `author` (User)
  - [ ] Create `backend/app/models/card_activity.py` (if not exists from Story 2.5)
  - [ ] Define `CardActivity`: id, card_id, user_id, action (enum), metadata (JSONB), created_at
  - [ ] Action enum: created, title_changed, description_updated, moved, assigned, unassigned, label_added, label_removed, due_date_set, etc.
  - [ ] Create Alembic migration for new tables

- [ ] **Task 2: Create comment API endpoints** (AC: 2, 3, 5, 6)
  - [ ] Implement `GET /cards/{id}/comments` - list card comments (paginated)
  - [ ] Implement `POST /cards/{id}/comments` - create new comment
  - [ ] Implement `PATCH /comments/{id}` - update comment text (author only)
  - [ ] Implement `DELETE /comments/{id}` - soft delete comment (author only)
  - [ ] Support pagination: query params `offset` (default 0), `limit` (default 20)
  - [ ] Return comments with author details (avatar, name)

- [ ] **Task 3: Create activity API endpoint** (AC: 7, 8, 9)
  - [ ] Implement `GET /cards/{id}/activity` - list card activities (paginated)
  - [ ] Return activities with user details and metadata
  - [ ] Format activity descriptions using metadata: "moved from {from_column} to {to_column}"
  - [ ] Support same pagination as comments endpoint

- [ ] **Task 4: Create timeline API endpoint combining comments and activities** (AC: 10, 11)
  - [ ] Implement `GET /cards/{id}/timeline` - combined comments + activities
  - [ ] Merge comments and activities, sort by timestamp descending
  - [ ] Add `type` field: "comment" or "activity" to distinguish entries
  - [ ] Support pagination: offset, limit query params
  - [ ] Return total count for "Load More" button logic

- [ ] **Task 5: Create comment service layer** (AC: 3, 5, 6, 13)
  - [ ] Create `backend/app/services/comment_service.py`
  - [ ] Implement `create_comment(card_id, user_id, text)` - creates comment, logs activity
  - [ ] Implement `update_comment(comment_id, text, user_id)` - validates author
  - [ ] Implement `delete_comment(comment_id, user_id)` - soft delete, validates author
  - [ ] Parse @mentions in comment text: extract mentioned user IDs
  - [ ] Create notifications for mentioned users
  - [ ] Broadcast WebSocket event when comment posted

- [ ] **Task 6: Implement activity logging service** (AC: 8, 9)
  - [ ] Create `backend/app/services/activity_service.py`
  - [ ] Implement `log_activity(card_id, user_id, action, metadata)` method
  - [ ] Called from card service methods: create, update, move, assign, etc.
  - [ ] Metadata stores context: old values, new values, column names
  - [ ] Generate human-readable descriptions from action + metadata
  - [ ] Example: action="moved", metadata={"from": "To Do", "to": "Done"} â†’ "moved from To Do to Done"

- [ ] **Task 7: Create comments section in card detail modal** (AC: 1, 2, 3, 4)
  - [ ] Update `frontend/src/components/board/card-detail-modal.tsx`
  - [ ] Add "Comments & Activity" tab or section
  - [ ] Create `frontend/src/components/board/card-timeline.tsx` component
  - [ ] Display timeline items (comments + activities) in scrollable container
  - [ ] Fetch timeline: `useQuery({ queryKey: ['card-timeline', cardId] })`
  - [ ] Add comment input box with markdown editor (reuse from description)
  - [ ] "Add Comment" button calls `POST /cards/{id}/comments`

- [ ] **Task 8: Create timeline item components** (AC: 4, 9)
  - [ ] Create `frontend/src/components/board/timeline-comment.tsx`
  - [ ] Display: author avatar, name, timestamp (relative: "2 hours ago" using date-fns)
  - [ ] Render comment text as markdown with ReactMarkdown
  - [ ] Show "Edit" and "Delete" buttons for comment author only
  - [ ] Create `frontend/src/components/board/timeline-activity.tsx`
  - [ ] Display: user avatar, activity description, timestamp
  - [ ] Use muted text color to distinguish from comments

- [ ] **Task 9: Implement comment editing** (AC: 5)
  - [ ] Add "Edit" button to comments (visible to author only)
  - [ ] On click, replace comment text with inline editor (textarea)
  - [ ] "Save" button calls `PATCH /comments/{id}` with updated text
  - [ ] "Cancel" button reverts to original text
  - [ ] Show "(edited)" indicator next to timestamp if comment edited
  - [ ] Use optimistic update with rollback on error

- [ ] **Task 10: Implement comment deletion** (AC: 6)
  - [ ] Add "Delete" button to comments (visible to author only)
  - [ ] Show confirmation dialog: "Delete this comment?"
  - [ ] On confirm, call `DELETE /comments/{id}`
  - [ ] Soft delete: comment remains in database but hidden from UI
  - [ ] Optionally show "[deleted]" placeholder instead of removing entirely
  - [ ] Optimistic update: remove immediately, restore on error

- [ ] **Task 11: Implement pagination for timeline** (AC: 11)
  - [ ] Load initial 20 timeline items on card open
  - [ ] Show "Load More" button if total count > current items
  - [ ] On click, fetch next 20 items with offset
  - [ ] Append new items to timeline (don't replace)
  - [ ] Use infinite query pattern with TanStack Query: `useInfiniteQuery`
  - [ ] Disable button when loading or no more items

- [ ] **Task 12: Add real-time timeline updates via WebSocket** (AC: 12)
  - [ ] Backend broadcasts `comment_created` event when comment posted
  - [ ] Backend broadcasts `activity_created` event when activity logged
  - [ ] Frontend subscribes to card-specific WebSocket channel
  - [ ] On event, prepend new comment/activity to timeline
  - [ ] Show subtle animation when new item appears (slide-in from top)
  - [ ] Display toast: "[User] commented on this card"

- [ ] **Task 13: Implement @mention autocomplete** (AC: 13)
  - [ ] Create `frontend/src/components/board/mention-autocomplete.tsx`
  - [ ] Detect "@" character typed in comment input
  - [ ] Show dropdown of workspace members matching typed text
  - [ ] Dropdown positioned below cursor (use @tiptap/suggestion or similar)
  - [ ] Selecting user inserts "@username" into text
  - [ ] Store mentioned user IDs in comment metadata
  - [ ] Backend parses mentions on comment creation

- [ ] **Task 14: Implement notification system** (AC: 14, 15)
  - [ ] Create `backend/app/models/notification.py`
  - [ ] Define `Notification`: id, user_id, type, card_id, comment_id, read_at, created_at
  - [ ] Create notification when user @mentioned in comment
  - [ ] API endpoint: `GET /notifications` - list user notifications
  - [ ] API endpoint: `PATCH /notifications/{id}/read` - mark as read
  - [ ] API endpoint: `PATCH /notifications/read-all` - mark all as read
  - [ ] Return unread count in user session data

- [ ] **Task 15: Create notification UI components** (AC: 14, 15)
  - [ ] Add bell icon to navigation bar
  - [ ] Show unread count badge on bell icon (red circle with number)
  - [ ] Create notification dropdown: `frontend/src/components/layout/notification-dropdown.tsx`
  - [ ] Display list of notifications with: card title, comment snippet, author, timestamp
  - [ ] Clicking notification marks as read and navigates to card
  - [ ] "Mark all as read" button at bottom of dropdown
  - [ ] Fetch notifications: `useQuery({ queryKey: ['notifications'] })`

- [ ] **Task 16: Write tests for comments and activity** (AC: 1-15)
  - [ ] Unit test: Create comment and verify author can edit/delete
  - [ ] Unit test: Activity logging generates correct descriptions
  - [ ] Unit test: @mention parsing extracts user IDs
  - [ ] Integration test: Comment CRUD endpoints
  - [ ] Integration test: Timeline endpoint combines comments + activities
  - [ ] Integration test: Notification creation on @mention
  - [ ] Component test: Comment posting and editing
  - [ ] Component test: @mention autocomplete
  - [ ] E2E test: Full comment workflow (post, edit, delete)
  - [ ] E2E test: @mention notification workflow

---

## Dev Notes

### Database Models

```python
# backend/app/models/card_comment.py
from sqlalchemy import Column, String, Text, ForeignKey, DateTime, func
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
import uuid
from app.core.database import Base

class CardComment(Base):
    __tablename__ = "card_comments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    card_id = Column(UUID(as_uuid=True), ForeignKey("cards.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    text = Column(Text, nullable=False)  # Markdown
    metadata = Column(JSONB, default=dict)  # Store mentioned_users: [user_id, ...]
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    deleted_at = Column(DateTime(timezone=True))  # Soft delete

    # Relationships
    card = relationship("Card", back_populates="comments")
    author = relationship("User")

# backend/app/models/card_activity.py
import enum

class ActivityAction(str, enum.Enum):
    CREATED = "created"
    TITLE_CHANGED = "title_changed"
    DESCRIPTION_UPDATED = "description_updated"
    MOVED = "moved"
    ASSIGNED = "assigned"
    UNASSIGNED = "unassigned"
    LABEL_ADDED = "label_added"
    LABEL_REMOVED = "label_removed"
    DUE_DATE_SET = "due_date_set"
    PRIORITY_CHANGED = "priority_changed"
    COMMENTED = "commented"

class CardActivity(Base):
    __tablename__ = "card_activity"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    card_id = Column(UUID(as_uuid=True), ForeignKey("cards.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    action = Column(SQLEnum(ActivityAction), nullable=False)
    metadata = Column(JSONB, default=dict)  # Context: from_value, to_value, column_names, etc.
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    card = relationship("Card", back_populates="activities")
    user = relationship("User")

    def to_description(self) -> str:
        """Generate human-readable activity description."""
        if self.action == ActivityAction.MOVED:
            return f"moved from {self.metadata.get('from_column')} to {self.metadata.get('to_column')}"
        elif self.action == ActivityAction.ASSIGNED:
            return f"assigned to {self.metadata.get('assignee_name')}"
        elif self.action == ActivityAction.LABEL_ADDED:
            return f"added label {self.metadata.get('label_name')}"
        # ... more actions
        return self.action.value.replace('_', ' ')
```

### Activity Service Implementation

```python
# backend/app/services/activity_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.card_activity import CardActivity, ActivityAction
from uuid import UUID

class ActivityService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def log_activity(
        self,
        card_id: UUID,
        user_id: UUID,
        action: ActivityAction,
        metadata: dict = None
    ) -> CardActivity:
        """Log card activity."""
        activity = CardActivity(
            card_id=card_id,
            user_id=user_id,
            action=action,
            metadata=metadata or {}
        )
        self.db.add(activity)
        await self.db.commit()
        await self.db.refresh(activity)
        return activity

    # Helper methods for common activities
    async def log_card_moved(self, card_id: UUID, user_id: UUID, from_column: str, to_column: str):
        return await self.log_activity(
            card_id,
            user_id,
            ActivityAction.MOVED,
            {"from_column": from_column, "to_column": to_column}
        )

    async def log_user_assigned(self, card_id: UUID, user_id: UUID, assignee_name: str):
        return await self.log_activity(
            card_id,
            user_id,
            ActivityAction.ASSIGNED,
            {"assignee_name": assignee_name}
        )
```

### Frontend Card Timeline Component

```typescript
// frontend/src/components/board/card-timeline.tsx
'use client'

import { useInfiniteQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { TimelineComment } from './timeline-comment'
import { TimelineActivity } from './timeline-activity'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { useState } from 'react'
import { api } from '@/lib/api/client'
import { toast } from 'sonner'

interface CardTimelineProps {
  cardId: string
}

export function CardTimeline({ cardId }: CardTimelineProps) {
  const [commentText, setCommentText] = useState('')
  const queryClient = useQueryClient()

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['card-timeline', cardId],
    queryFn: ({ pageParam = 0 }) =>
      api.get(`/cards/${cardId}/timeline?offset=${pageParam}&limit=20`),
    getNextPageParam: (lastPage, pages) => {
      const loaded = pages.flatMap(p => p.items).length
      return loaded < lastPage.total ? loaded : undefined
    },
  })

  const postCommentMutation = useMutation({
    mutationFn: (text: string) =>
      api.post(`/cards/${cardId}/comments`, { text }),
    onSuccess: () => {
      toast.success('Comment posted')
      queryClient.invalidateQueries({ queryKey: ['card-timeline', cardId] })
      setCommentText('')
    },
  })

  const handlePostComment = () => {
    if (!commentText.trim()) return
    postCommentMutation.mutate(commentText)
  }

  const timelineItems = data?.pages.flatMap(page => page.items) || []

  return (
    <div className="space-y-4">
      {/* Comment Input */}
      <div className="space-y-2">
        <Textarea
          value={commentText}
          onChange={(e) => setCommentText(e.target.value)}
          placeholder="Add a comment... (Markdown supported)"
          rows={3}
        />
        <Button
          onClick={handlePostComment}
          disabled={postCommentMutation.isPending || !commentText.trim()}
        >
          {postCommentMutation.isPending ? 'Posting...' : 'Add Comment'}
        </Button>
      </div>

      {/* Timeline */}
      <div className="space-y-4">
        {timelineItems.map((item: any) => {
          if (item.type === 'comment') {
            return <TimelineComment key={item.id} comment={item} cardId={cardId} />
          } else {
            return <TimelineActivity key={item.id} activity={item} />
          }
        })}

        {hasNextPage && (
          <Button
            variant="outline"
            onClick={() => fetchNextPage()}
            disabled={isFetchingNextPage}
            className="w-full"
          >
            {isFetchingNextPage ? 'Loading...' : 'Load More'}
          </Button>
        )}
      </div>
    </div>
  )
}
```

### Timeline Comment Component

```typescript
// frontend/src/components/board/timeline-comment.tsx
'use client'

import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Pencil, Trash2 } from 'lucide-react'
import { formatDistanceToNow } from 'date-fns'
import ReactMarkdown from 'react-markdown'
import { api } from '@/lib/api/client'
import { useAuth } from '@/lib/hooks/use-auth'

export function TimelineComment({ comment, cardId }: any) {
  const [isEditing, setIsEditing] = useState(false)
  const [editText, setEditText] = useState(comment.text)
  const { user } = useAuth()
  const queryClient = useQueryClient()

  const isAuthor = user?.id === comment.author.id

  const updateMutation = useMutation({
    mutationFn: (text: string) => api.patch(`/comments/${comment.id}`, { text }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['card-timeline', cardId] })
      setIsEditing(false)
    },
  })

  const deleteMutation = useMutation({
    mutationFn: () => api.delete(`/comments/${comment.id}`),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['card-timeline', cardId] })
    },
  })

  const handleDelete = () => {
    if (confirm('Delete this comment?')) {
      deleteMutation.mutate()
    }
  }

  return (
    <div className="flex gap-3">
      <Avatar className="h-8 w-8">
        <AvatarImage src={comment.author.avatar_url} />
        <AvatarFallback>{comment.author.username[0]}</AvatarFallback>
      </Avatar>

      <div className="flex-1 space-y-1">
        <div className="flex items-center gap-2">
          <span className="font-semibold text-sm">{comment.author.username}</span>
          <span className="text-xs text-muted-foreground">
            {formatDistanceToNow(new Date(comment.created_at), { addSuffix: true })}
          </span>
          {comment.updated_at !== comment.created_at && (
            <span className="text-xs text-muted-foreground">(edited)</span>
          )}
        </div>

        {isEditing ? (
          <div className="space-y-2">
            <Textarea
              value={editText}
              onChange={(e) => setEditText(e.target.value)}
              rows={3}
            />
            <div className="flex gap-2">
              <Button size="sm" onClick={() => updateMutation.mutate(editText)}>
                Save
              </Button>
              <Button size="sm" variant="outline" onClick={() => setIsEditing(false)}>
                Cancel
              </Button>
            </div>
          </div>
        ) : (
          <div className="prose prose-sm max-w-none">
            <ReactMarkdown>{comment.text}</ReactMarkdown>
          </div>
        )}

        {isAuthor && !isEditing && (
          <div className="flex gap-2 pt-1">
            <Button
              variant="ghost"
              size="sm"
              className="h-7 text-xs"
              onClick={() => setIsEditing(true)}
            >
              <Pencil className="mr-1 h-3 w-3" />
              Edit
            </Button>
            <Button
              variant="ghost"
              size="sm"
              className="h-7 text-xs text-destructive"
              onClick={handleDelete}
            >
              <Trash2 className="mr-1 h-3 w-3" />
              Delete
            </Button>
          </div>
        )}
      </div>
    </div>
  )
}
```

### Testing

**Integration Test - Comments:**
```python
@pytest.mark.asyncio
async def test_create_edit_delete_comment(client, test_card, auth_headers):
    # Create comment
    response = await client.post(
        f"/cards/{test_card.id}/comments",
        json={"text": "Great work!"},
        headers=auth_headers
    )
    assert response.status_code == 201
    comment = response.json()

    # Edit comment
    response = await client.patch(
        f"/comments/{comment['id']}",
        json={"text": "Excellent work!"},
        headers=auth_headers
    )
    assert response.status_code == 200
    assert response.json()["text"] == "Excellent work!"

    # Delete comment
    response = await client.delete(
        f"/comments/{comment['id']}",
        headers=auth_headers
    )
    assert response.status_code == 204
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 2 Story 2.7 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
