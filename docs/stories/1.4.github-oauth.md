# Story 1.4: GitHub OAuth Authentication

## Status
Draft

---

## Story

**As a** user,
**I want** to sign in to Taskly using my GitHub account,
**so that** I can access the application without creating a new password.

---

## Acceptance Criteria

1. GitHub OAuth App registered with appropriate callback URL for local development and staging
2. Login page displays "Sign in with GitHub" button with GitHub branding (Octicon logo)
3. Clicking button initiates OAuth flow redirecting to GitHub authorization page
4. After user authorizes, GitHub redirects back to Taskly callback endpoint with authorization code
5. Backend exchanges authorization code for GitHub access token and stores encrypted in database
6. Backend fetches user profile from GitHub API (username, email, avatar) and creates/updates user record
7. Backend issues JWT access token (15 min expiration) and refresh token (7 day expiration) to frontend
8. Frontend stores tokens securely (httpOnly cookies or secure localStorage) and includes in subsequent API requests
9. Logout endpoint invalidates tokens and clears frontend storage
10. Unauthorized API requests (missing or expired token) return 401 status with clear error message
11. Token refresh mechanism automatically requests new access token using refresh token before expiration
12. GitHub API rate limits respected (cache user profile data, avoid excessive API calls)

---

## Tasks / Subtasks

- [ ] **Task 1: Register GitHub OAuth App** (AC: 1)
  - [ ] Go to GitHub Settings → Developer Settings → OAuth Apps → New OAuth App
  - [ ] Set application name: "Taskly (Development)"
  - [ ] Set homepage URL: `http://localhost:3000`
  - [ ] Set authorization callback URL: `http://localhost:3000/auth/callback`
  - [ ] Register app and note Client ID and Client Secret
  - [ ] Store credentials in backend `.env`: `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`
  - [ ] Store Client ID in frontend `.env.local`: `NEXT_PUBLIC_GITHUB_CLIENT_ID`
  - [ ] Repeat for staging environment with staging URL

- [ ] **Task 2: Create authentication service in backend** (AC: 5, 6, 7)
  - [ ] Create `backend/app/services/auth_service.py`
  - [ ] Implement `exchange_code_for_token(code: str)` - calls GitHub OAuth token endpoint
  - [ ] Implement `fetch_github_user(access_token: str)` - calls GitHub user API
  - [ ] Implement `create_or_update_user(github_user: dict, access_token: str)` - upserts User model
  - [ ] Implement `generate_jwt_tokens(user: User)` - creates access + refresh tokens
  - [ ] Implement `verify_access_token(token: str)` - validates JWT, returns user
  - [ ] Implement `refresh_access_token(refresh_token: str)` - issues new access token
  - [ ] Add token encryption for GitHub access token before storing in database

- [ ] **Task 3: Create JWT token utilities** (AC: 7, 10, 11)
  - [ ] Create `backend/app/core/security.py`
  - [ ] Implement `create_access_token(user_id: UUID)` - generates JWT with 15 min expiration
  - [ ] Implement `create_refresh_token(user_id: UUID)` - generates JWT with 7 day expiration
  - [ ] Implement `verify_token(token: str)` - validates JWT signature and expiration
  - [ ] Use PyJWT library with HS256 algorithm
  - [ ] Load JWT secret from environment variable `SECRET_KEY`
  - [ ] Add correlation ID to JWT payload for request tracing

- [ ] **Task 4: Create authentication API endpoints** (AC: 3, 4, 5, 6, 7, 9, 10, 11)
  - [ ] Create `backend/app/api/auth.py` router
  - [ ] Implement `GET /auth/github/login` - redirects to GitHub OAuth authorization URL
  - [ ] Implement `GET /auth/github/callback` - handles OAuth callback, exchanges code for tokens
  - [ ] Implement `POST /auth/refresh` - accepts refresh token, returns new access token
  - [ ] Implement `POST /auth/logout` - invalidates refresh token (add to blacklist in Redis)
  - [ ] Add error handling: invalid code, GitHub API errors, token validation errors
  - [ ] Return tokens in response body (frontend will store in localStorage or cookies)

- [ ] **Task 5: Create authentication middleware** (AC: 8, 10)
  - [ ] Create `backend/app/api/dependencies.py`
  - [ ] Implement `get_current_user()` dependency - extracts JWT from Authorization header
  - [ ] Verify token using `security.verify_token()`
  - [ ] Load user from database by user_id from token payload
  - [ ] Raise 401 HTTPException if token missing, invalid, or expired
  - [ ] Add dependency to protected routes: `current_user: User = Depends(get_current_user)`
  - [ ] Exclude health check and auth endpoints from authentication requirement

- [ ] **Task 6: Implement token refresh logic in backend** (AC: 11)
  - [ ] Create `RefreshToken` model to track issued refresh tokens
  - [ ] Store refresh tokens in database with: user_id, token_hash, expires_at, created_at
  - [ ] On `/auth/refresh` endpoint, verify refresh token exists in database and not expired
  - [ ] Generate new access token, return to client
  - [ ] Implement token rotation: invalidate old refresh token, issue new one (optional security enhancement)
  - [ ] Add refresh token cleanup job: delete expired tokens older than 7 days

- [ ] **Task 7: Create login page in frontend** (AC: 2, 3)
  - [ ] Create `frontend/src/app/(auth)/login/page.tsx`
  - [ ] Design login page: centered card with Taskly logo, tagline, "Sign in with GitHub" button
  - [ ] Use shadcn/ui Button component styled with GitHub colors
  - [ ] Add GitHub Octicon logo to button (use lucide-react `Github` icon)
  - [ ] On button click, redirect to `/api/auth/github/login` (backend endpoint)
  - [ ] Add loading state while redirecting
  - [ ] Display error message if `?error=` query param present (from callback failure)

- [ ] **Task 8: Create OAuth callback handler in frontend** (AC: 4, 8)
  - [ ] Create `frontend/src/app/(auth)/callback/page.tsx`
  - [ ] Extract authorization code from URL query params
  - [ ] Call backend `/auth/github/callback?code=...` endpoint
  - [ ] On success, store access_token and refresh_token in localStorage
  - [ ] Redirect to `/workspaces` (dashboard)
  - [ ] On error, redirect to `/login?error=auth_failed` with error message
  - [ ] Add loading spinner while processing callback

- [ ] **Task 9: Implement API client with token management** (AC: 8, 10, 11)
  - [ ] Update `frontend/lib/api/client.ts` to include Authorization header
  - [ ] Read access_token from localStorage, add to headers: `Authorization: Bearer <token>`
  - [ ] Implement 401 response interceptor: detect token expiration
  - [ ] On 401, attempt token refresh: call `POST /auth/refresh` with refresh_token
  - [ ] If refresh succeeds, retry original request with new access_token
  - [ ] If refresh fails, clear tokens and redirect to `/login`
  - [ ] Update tokens in localStorage after successful refresh

- [ ] **Task 10: Create logout functionality** (AC: 9)
  - [ ] Add logout button to user menu in frontend navigation
  - [ ] On logout click, call backend `POST /auth/logout` with refresh_token
  - [ ] Clear localStorage: remove access_token and refresh_token
  - [ ] Redirect to `/login` page
  - [ ] Invalidate TanStack Query cache
  - [ ] Backend adds refresh_token to Redis blacklist (TTL = token expiration)

- [ ] **Task 11: Create useAuth hook for frontend** (AC: 8, 9, 10)
  - [ ] Create `frontend/lib/hooks/use-auth.ts`
  - [ ] Expose `user` state (current authenticated user or null)
  - [ ] Expose `isAuthenticated` boolean
  - [ ] Expose `login()` function - redirects to login page
  - [ ] Expose `logout()` function - calls logout endpoint and clears state
  - [ ] Fetch current user on mount if tokens exist (call `GET /api/me` endpoint)
  - [ ] Use TanStack Query to cache user data
  - [ ] Provide AuthContext for global access

- [ ] **Task 12: Implement GitHub API rate limit handling** (AC: 12)
  - [ ] Cache GitHub user profile in database (User model already stores username, email, avatar)
  - [ ] Only call GitHub API `/user` endpoint during initial login or manual refresh
  - [ ] Add `github_profile_fetched_at` timestamp to User model
  - [ ] Refresh GitHub profile max once per hour (configurable)
  - [ ] If GitHub API rate limit exceeded (403 response), use cached data
  - [ ] Log rate limit warnings to Sentry for monitoring

- [ ] **Task 13: Add authentication to health check and protected routes** (AC: 10)
  - [ ] Update health check endpoint to remain public (no auth required)
  - [ ] Create `GET /api/me` endpoint - returns current user profile (requires auth)
  - [ ] Add authentication to workspace endpoints: `GET /workspaces`, `POST /workspaces/{id}`
  - [ ] Test unauthorized access returns 401 with clear error: `{"type": "unauthorized", "title": "Authentication Required", "detail": "Missing or invalid access token"}`
  - [ ] Test expired token returns 401 with error: `{"type": "token_expired", ...}`

- [ ] **Task 14: Write tests for authentication flow** (AC: 1-12)
  - [ ] Unit test: `test_create_access_token()` - verify JWT structure and expiration
  - [ ] Unit test: `test_verify_token()` - verify token validation and error handling
  - [ ] Integration test: OAuth callback flow with mocked GitHub API
  - [ ] Integration test: Token refresh flow
  - [ ] Integration test: Logout invalidates tokens
  - [ ] Integration test: Protected endpoint rejects invalid tokens
  - [ ] E2E test: Full login flow from button click to dashboard redirect

---

## Dev Notes

### GitHub OAuth Flow Diagram

```
1. User clicks "Sign in with GitHub" on /login
   ↓
2. Frontend redirects to GET /auth/github/login (backend)
   ↓
3. Backend redirects to https://github.com/login/oauth/authorize?client_id=...&redirect_uri=...&scope=user:email
   ↓
4. User authorizes on GitHub
   ↓
5. GitHub redirects to http://localhost:3000/auth/callback?code=ABC123
   ↓
6. Frontend extracts code, calls GET /auth/github/callback?code=ABC123 (backend)
   ↓
7. Backend exchanges code for GitHub access_token (POST https://github.com/login/oauth/access_token)
   ↓
8. Backend fetches user profile (GET https://api.github.com/user with access_token)
   ↓
9. Backend creates/updates User in database
   ↓
10. Backend generates JWT access_token (15 min) and refresh_token (7 days)
   ↓
11. Backend returns tokens to frontend: {"access_token": "...", "refresh_token": "..."}
   ↓
12. Frontend stores tokens in localStorage
   ↓
13. Frontend redirects to /workspaces
```

### JWT Token Structure

**Access Token (15 min expiration):**
```json
{
  "sub": "user-uuid",
  "type": "access",
  "exp": 1234567890,
  "iat": 1234567000,
  "correlation_id": "request-uuid"
}
```

**Refresh Token (7 day expiration):**
```json
{
  "sub": "user-uuid",
  "type": "refresh",
  "exp": 1234567890,
  "iat": 1234567000
}
```

### Backend Auth Service Implementation

```python
# backend/app/services/auth_service.py
import httpx
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.user import User
from app.core.security import create_access_token, create_refresh_token
import os

GITHUB_CLIENT_ID = os.getenv("GITHUB_CLIENT_ID")
GITHUB_CLIENT_SECRET = os.getenv("GITHUB_CLIENT_SECRET")

class AuthService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def exchange_code_for_token(self, code: str) -> str:
        """Exchange OAuth code for GitHub access token."""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "https://github.com/login/oauth/access_token",
                headers={"Accept": "application/json"},
                data={
                    "client_id": GITHUB_CLIENT_ID,
                    "client_secret": GITHUB_CLIENT_SECRET,
                    "code": code,
                }
            )
            response.raise_for_status()
            data = response.json()
            return data["access_token"]

    async def fetch_github_user(self, access_token: str) -> dict:
        """Fetch user profile from GitHub API."""
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.github.com/user",
                headers={"Authorization": f"Bearer {access_token}"}
            )
            response.raise_for_status()
            return response.json()

    async def create_or_update_user(self, github_user: dict, access_token: str) -> User:
        """Create or update user from GitHub profile."""
        # Check if user exists
        result = await self.db.execute(
            select(User).where(User.github_id == github_user["id"])
        )
        user = result.scalar_one_or_none()

        if user:
            # Update existing user
            user.username = github_user["login"]
            user.email = github_user["email"]
            user.avatar_url = github_user["avatar_url"]
            user.github_access_token = self.encrypt_token(access_token)
        else:
            # Create new user
            user = User(
                github_id=github_user["id"],
                username=github_user["login"],
                email=github_user["email"],
                avatar_url=github_user["avatar_url"],
                github_access_token=self.encrypt_token(access_token)
            )
            self.db.add(user)

        await self.db.commit()
        await self.db.refresh(user)
        return user

    async def generate_jwt_tokens(self, user: User) -> dict:
        """Generate access and refresh tokens."""
        access_token = create_access_token(user.id)
        refresh_token = create_refresh_token(user.id)

        # Store refresh token in database
        refresh_token_record = RefreshToken(
            user_id=user.id,
            token_hash=hash_token(refresh_token),
            expires_at=datetime.utcnow() + timedelta(days=7)
        )
        self.db.add(refresh_token_record)
        await self.db.commit()

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "expires_in": 900  # 15 minutes in seconds
        }

    def encrypt_token(self, token: str) -> str:
        """Encrypt GitHub access token before storing."""
        # TODO: Implement AES encryption
        return token  # Placeholder
```

### Security Module Implementation

```python
# backend/app/core/security.py
from datetime import datetime, timedelta
import jwt
from uuid import UUID
import os

SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-key-change-in-production")
ALGORITHM = "HS256"

def create_access_token(user_id: UUID) -> str:
    """Create JWT access token (15 min expiration)."""
    expire = datetime.utcnow() + timedelta(minutes=15)
    payload = {
        "sub": str(user_id),
        "type": "access",
        "exp": expire,
        "iat": datetime.utcnow(),
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user_id: UUID) -> str:
    """Create JWT refresh token (7 day expiration)."""
    expire = datetime.utcnow() + timedelta(days=7)
    payload = {
        "sub": str(user_id),
        "type": "refresh",
        "exp": expire,
        "iat": datetime.utcnow(),
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str, expected_type: str = "access") -> UUID:
    """Verify JWT token and return user_id."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != expected_type:
            raise ValueError(f"Invalid token type. Expected {expected_type}")
        user_id = UUID(payload["sub"])
        return user_id
    except jwt.ExpiredSignatureError:
        raise ValueError("Token expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")
```

### Authentication Dependency

```python
# backend/app/api/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.security import verify_token
from app.models.user import User
from sqlalchemy import select

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user from JWT token."""
    token = credentials.credentials

    try:
        user_id = verify_token(token, expected_type="access")
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )

    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )

    return user
```

### Frontend Login Page

```typescript
// frontend/src/app/(auth)/login/page.tsx
'use client'

import { Github } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { useSearchParams } from 'next/navigation'

export default function LoginPage() {
  const searchParams = useSearchParams()
  const error = searchParams.get('error')

  const handleGitHubLogin = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/auth/github/login`
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md p-8">
        <div className="mb-8 text-center">
          <h1 className="text-3xl font-bold">Taskly</h1>
          <p className="mt-2 text-gray-600">Move a Card, Ship the Code</p>
        </div>

        {error && (
          <div className="mb-4 rounded-md bg-red-50 p-4 text-sm text-red-800">
            Authentication failed. Please try again.
          </div>
        )}

        <Button
          onClick={handleGitHubLogin}
          className="w-full"
          size="lg"
        >
          <Github className="mr-2 h-5 w-5" />
          Sign in with GitHub
        </Button>

        <p className="mt-6 text-center text-xs text-gray-500">
          By signing in, you agree to our Terms of Service and Privacy Policy.
        </p>
      </Card>
    </div>
  )
}
```

### Frontend Callback Handler

```typescript
// frontend/src/app/(auth)/callback/page.tsx
'use client'

import { useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { api } from '@/lib/api/client'

export default function CallbackPage() {
  const router = useRouter()
  const searchParams = useSearchParams()

  useEffect(() => {
    const code = searchParams.get('code')

    if (!code) {
      router.push('/login?error=missing_code')
      return
    }

    handleCallback(code)
  }, [])

  async function handleCallback(code: string) {
    try {
      const response = await api.get(`/auth/github/callback?code=${code}`)

      // Store tokens
      localStorage.setItem('access_token', response.access_token)
      localStorage.setItem('refresh_token', response.refresh_token)

      // Redirect to dashboard
      router.push('/workspaces')
    } catch (error) {
      console.error('Auth callback failed:', error)
      router.push('/login?error=auth_failed')
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <div className="mb-4 h-12 w-12 animate-spin rounded-full border-4 border-gray-300 border-t-blue-600" />
        <p className="text-gray-600">Signing you in...</p>
      </div>
    </div>
  )
}
```

### Frontend useAuth Hook

```typescript
// frontend/lib/hooks/use-auth.ts
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api/client'
import { useRouter } from 'next/navigation'

interface User {
  id: string
  username: string
  email: string
  avatar_url: string
}

export function useAuth() {
  const router = useRouter()
  const queryClient = useQueryClient()

  const { data: user, isLoading } = useQuery({
    queryKey: ['current-user'],
    queryFn: async () => {
      const token = localStorage.getItem('access_token')
      if (!token) return null
      return api.get<User>('/api/me')
    },
    retry: false,
  })

  const logout = async () => {
    const refreshToken = localStorage.getItem('refresh_token')
    if (refreshToken) {
      try {
        await api.post('/auth/logout', { refresh_token: refreshToken })
      } catch (error) {
        console.error('Logout error:', error)
      }
    }

    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
    queryClient.clear()
    router.push('/login')
  }

  return {
    user,
    isAuthenticated: !!user,
    isLoading,
    logout,
  }
}
```

### Testing

**Unit Test - JWT Creation:**
```python
# backend/tests/unit/test_security.py
from app.core.security import create_access_token, verify_token
import uuid

def test_create_and_verify_access_token():
    user_id = uuid.uuid4()
    token = create_access_token(user_id)
    verified_id = verify_token(token, expected_type="access")
    assert verified_id == user_id
```

**Integration Test - OAuth Flow:**
```python
# backend/tests/integration/test_auth.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_oauth_callback(client: AsyncClient, mock_github_api):
    response = await client.get("/auth/github/callback?code=test_code")
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert "refresh_token" in data
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 1 Story 1.4 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

---

## QA Results
*To be populated by QA agent after implementation review*
