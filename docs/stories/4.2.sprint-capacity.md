# Story 4.2: Sprint Capacity Management

## Status
Draft

---

## Story

**As a** scrum master,
**I want** to track sprint capacity and team workload,
**so that** I can prevent over-commitment and balance work distribution.

---

## Acceptance Criteria

1. Sprint detail view displays capacity utilization chart: progress bar showing used/total story points
2. Progress bar color-coded: green (<80%), yellow (80-100%), red (>100% over capacity)
3. Sprint sidebar shows quick stats: "24/40 points" with percentage "(60%)"
4. Adding card with story points to sprint auto-updates capacity calculation in real-time
5. Capacity chart breaks down by assignee: each team member shows allocated points vs personal capacity
6. Board members can set personal capacity in profile: "Story points per sprint" (default: 10)
7. Unassigned cards in sprint show in "Unassigned" section of capacity breakdown
8. Sprint planning mode allows drag-and-drop cards from backlog with live capacity feedback
9. Warning shown when dragging card would exceed sprint capacity: "This will exceed capacity by X points"
10. Sprint capacity configurable: edit sprint to change total capacity points

---

## Tasks / Subtasks

- [ ] **Task 1: Add capacity calculation service** (AC: 1, 2, 3, 4)
  - [ ] Calculate total story points in sprint
  - [ ] Calculate capacity utilization percentage
  - [ ] Return color code based on percentage

- [ ] **Task 2: Add personal capacity to User model** (AC: 6)
  - [ ] Add `story_points_per_sprint` field to users table (default 10)
  - [ ] API endpoint to update personal capacity

- [ ] **Task 3: Create capacity chart component** (AC: 1, 2, 5)
  - [ ] Display progress bar with utilization
  - [ ] Break down by assignee
  - [ ] Show unassigned cards separately

- [ ] **Task 4: Implement live capacity feedback** (AC: 8, 9)
  - [ ] Calculate new capacity when dragging card
  - [ ] Show warning tooltip if exceeds capacity
  - [ ] Color preview bar based on new utilization

- [ ] **Task 5: Write tests** (AC: 1-10)
  - [ ] Unit test: Capacity calculation with multiple cards
  - [ ] Component test: Capacity chart rendering

---

## Dev Notes

### Personal Capacity Defaults

**Problem:** New team members join workspace - what's their default capacity?

**Solution: Tiered Default System**

1. **System Default:** 10 story points per sprint
   - Applied when user first joins any workspace
   - Reasonable baseline for most developers

2. **Workspace-Level Default:** Configurable by workspace admin
   - Override system default for entire workspace
   - Example: "Junior developers: 5 points, Senior: 15 points"
   - Set in Workspace Settings → "Default Capacity"

3. **User Personal Override:** Each user can set their own capacity
   - Takes precedence over workspace and system defaults
   - Editable in User Profile → "Story Points Per Sprint"
   - Persists across all workspaces

**Capacity Precedence Order:**
```
User Personal Capacity > Workspace Default > System Default (10 points)
```

**Database Schema:**

```python
class User(Base):
    # ... existing fields ...
    default_story_points_per_sprint = Column(Integer, default=10)  # User's personal default

class Workspace(Base):
    # ... existing fields ...
    default_capacity_per_member = Column(Integer, default=10)  # Workspace-level default

class WorkspaceMember(Base):
    # ... existing fields ...
    custom_capacity = Column(Integer, nullable=True)  # Per-workspace override
```

**Capacity Resolution Logic:**

```python
async def get_user_capacity(user_id: UUID, workspace_id: UUID) -> int:
    """Get effective capacity for user in specific workspace."""
    member = await db.get(WorkspaceMember, (user_id, workspace_id))

    # 1. Check workspace-specific custom capacity
    if member.custom_capacity is not None:
        return member.custom_capacity

    # 2. Check user's personal default
    user = await db.get(User, user_id)
    if user.default_story_points_per_sprint != 10:  # User has custom default
        return user.default_story_points_per_sprint

    # 3. Check workspace default
    workspace = await db.get(Workspace, workspace_id)
    if workspace.default_capacity_per_member != 10:  # Workspace has custom default
        return workspace.default_capacity_per_member

    # 4. System default
    return 10
```

### Team Capacity Calculation

**Problem:** How is total sprint capacity calculated from individual member capacities?

**Solution: Sum of Active Member Capacities**

**Formula:**

```
Sprint Total Capacity = Σ (Active Member Capacity × Availability Factor)
```

**Calculation Logic:**

```python
async def calculate_team_capacity(sprint_id: UUID) -> dict:
    """Calculate total team capacity for sprint."""
    sprint = await db.get(Sprint, sprint_id)
    board = await db.get(Board, sprint.board_id)
    workspace = board.workspace

    # Get all workspace members
    members = await db.execute(
        select(WorkspaceMember)
        .where(WorkspaceMember.workspace_id == workspace.id)
        .options(selectinload(WorkspaceMember.user))
    )
    members = members.scalars().all()

    total_capacity = 0
    member_breakdown = []

    for member in members:
        # Get member's capacity
        capacity = await get_user_capacity(member.user_id, workspace.id)

        # Check if member has availability override for this sprint
        availability = await get_sprint_availability(member.user_id, sprint_id)
        # availability is 0.0 to 1.0 (e.g., 0.5 = half capacity, 1.0 = full capacity)

        effective_capacity = capacity * availability
        total_capacity += effective_capacity

        member_breakdown.append({
            "user_id": member.user_id,
            "username": member.user.username,
            "base_capacity": capacity,
            "availability": availability,
            "effective_capacity": effective_capacity
        })

    return {
        "total_capacity": total_capacity,
        "member_breakdown": member_breakdown,
        "member_count": len(members)
    }
```

**Per-Sprint Availability Overrides:**

Users can set per-sprint availability for vacation, partial availability:

```python
class SprintMemberAvailability(Base):
    """Track member availability for specific sprints."""
    __tablename__ = "sprint_member_availability"

    sprint_id = Column(UUID, ForeignKey("sprints.id", ondelete="CASCADE"), primary_key=True)
    user_id = Column(UUID, ForeignKey("users.id"), primary_key=True)
    availability_factor = Column(Float, default=1.0)  # 0.0 to 1.0
    reason = Column(String(255), nullable=True)  # "Vacation", "Part-time", etc.

    __table_args__ = (
        CheckConstraint('availability_factor >= 0.0 AND availability_factor <= 1.0'),
    )
```

**UI for Sprint Capacity Planning:**

```
Sprint Capacity Planning

Team Total Capacity: 42 story points

Member Breakdown:
┌──────────────────────────────────────────┐
│ Alice (Senior Dev)     15 pts  100% [✓]  │
│ Bob (Mid-level)        10 pts  100% [✓]  │
│ Charlie (Junior)        5 pts   50% [~]  │ ← Vacation: Apr 1-5
│ Dana (Senior Dev)      15 pts  100% [✓]  │
│ Eve (Mid-level)        10 pts    0% [✗]  │ ← Out sick
└──────────────────────────────────────────┘

Adjust Availability:
[Charlie] [50%] [Vacation ▼] [Apr 1-5]
```

### Unassigned Card Handling

**Problem:** How do unassigned cards count toward capacity?

**Solution: Unassigned cards DO count toward total sprint capacity but shown separately in breakdown**

**Rationale:** Unassigned cards still need to be completed in the sprint, consuming team capacity even if not yet assigned.

**Capacity Display:**

```
Sprint Capacity: 35/42 points (83%)

Assigned Breakdown:
├─ Alice: 12/15 pts
├─ Bob: 10/10 pts (at capacity)
├─ Charlie: 5/5 pts (at capacity)
└─ Dana: 3/15 pts

Unassigned: 5 pts
├─ Card: Fix bug in auth (3 pts)
└─ Card: Update docs (2 pts)
```

**When dragging unassigned card to sprint:**
- Show warning if exceeds total capacity: "Sprint at 100% capacity (42/42 pts). Adding this will exceed by 3 pts."
- Allow adding anyway (with warning)

**Capacity Calculation Code:**

```python
def calculate_sprint_capacity(sprint: Sprint) -> dict:
    cards = sprint.cards
    total_points = sum(c.story_points or 0 for c in cards)
    capacity = sprint.capacity_points

    # Break down by assignee
    assigned_points_by_user = {}
    unassigned_points = 0

    for card in cards:
        points = card.story_points or 0
        if card.assignees:
            for assignee in card.assignees:
                assigned_points_by_user.setdefault(assignee.id, 0)
                assigned_points_by_user[assignee.id] += points / len(card.assignees)  # Split evenly
        else:
            unassigned_points += points

    utilization = (total_points / capacity * 100) if capacity > 0 else 0

    if utilization < 80:
        color = "green"
    elif utilization <= 100:
        color = "yellow"
    else:
        color = "red"

    return {
        "total_points": total_points,
        "capacity": capacity,
        "utilization": utilization,
        "color": color,
        "assigned_breakdown": assigned_points_by_user,
        "unassigned_points": unassigned_points
    }
```

**Testing Requirements:**
- Unit test: Capacity resolution with workspace/user/system defaults
- Integration test: Team capacity calculation with availability overrides
- Unit test: Unassigned card handling in capacity calculation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from PRD Epic 4 Story 4.2 | Sarah (PO Agent) |
| 2025-10-23 | 1.1 | Added personal capacity defaults (system/workspace/user), team capacity aggregation formula, per-sprint availability, unassigned card handling | Bob (SM Agent) |
