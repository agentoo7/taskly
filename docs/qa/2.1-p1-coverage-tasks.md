# Story 2.1: P1 Tasks for 80% Coverage Target

**Story:** 2.1 Workspace Creation & Management
**Current Coverage:** 66% (overall project)
**Target Coverage:** 80% (overall project)
**Gap:** 14%
**Total Estimated Effort:** 12 hours

---

## Overview

All P0 blocker tasks are complete. The workspace module exceeds the 80% coverage target:
- ✅ workspace_service.py: 81%
- ✅ workspaces.py (API): 82%
- ✅ workspace.py (schemas): 97%
- ✅ 29/29 workspace tests passing

**Remaining Gap:** 14% to reach 80% overall project coverage

This document outlines P1 (high priority) tasks to close the remaining coverage gap.

---

## Coverage Gap Analysis

### Current State

| Module/File | Statements | Missed | Coverage | Gap to 80% |
|-------------|-----------|--------|----------|------------|
| **Workspace (complete)** | 148 | 23 | **84%** | ✅ EXCEEDS |
| workspace_service.py | 80 | 15 | 81% | +1% |
| workspaces.py | 38 | 7 | 82% | +2% |
| workspace.py | 30 | 1 | 97% | +17% |
| **Auth (needs work)** | 167 | 100 | **40%** | -40% |
| auth_service.py | 84 | 55 | 35% | -45% |
| auth.py (API) | 39 | 22 | 44% | -36% |
| dependencies.py | 44 | 23 | 48% | -32% |
| **Health (needs work)** | 26 | 18 | **31%** | -49% |
| health.py | 26 | 18 | 31% | -49% |
| **Other** | 472 | 182 | **61%** | -19% |

### Priority Targets

**High Impact (P1):**
1. Auth module (40% → 70%+) - 30% coverage gain, high value
2. Health module (31% → 80%+) - 49% coverage gain, easy wins
3. Workspace error scenarios (81% → 90%+) - 9% coverage gain, complete workspace testing

**Medium Impact (P2):**
4. Dependencies module (48% → 70%+) - 22% coverage gain
5. Other modules (models, middleware, etc.)

---

## P1 Task 1: Health Endpoint Tests

**Priority:** P1 (High Value - Easy Wins)
**Effort:** 2 hours
**Owner:** Backend Developer
**Issue ID:** TEST-002

### Objective

Achieve 80%+ coverage for health endpoints by testing database and Redis connectivity checks.

**Impact:** +49% coverage for health.py (31% → 80%+)

### Current Coverage

```
app/api/health.py: 31% coverage (26 statements, 18 missed)

Uncovered lines:
- Lines 23-48: Health check logic (database ping, Redis ping, version info)
```

### Acceptance Criteria

- [ ] Test: `test_health_check_returns_healthy_when_all_services_up`
  - Given: Database and Redis are accessible
  - When: GET /api/health
  - Then: 200 with {"status": "healthy", "database": "connected", "redis": "connected", "version": "..."}

- [ ] Test: `test_health_check_returns_degraded_when_database_down`
  - Given: Database connection fails
  - When: GET /api/health
  - Then: 503 with {"status": "degraded", "database": "disconnected", ...}

- [ ] Test: `test_health_check_returns_degraded_when_redis_down`
  - Given: Redis connection fails
  - When: GET /api/health
  - Then: 503 with {"status": "degraded", "redis": "disconnected", ...}

- [ ] Test: `test_health_check_includes_version_info`
  - Given: Normal operation
  - When: GET /api/health
  - Then: Response includes "version" field

### Implementation Details

**File to Create:** `backend/tests/integration/test_health.py`

**Required Fixtures:**
```python
@pytest.fixture
def mock_db_failure(monkeypatch):
    """Mock database connection failure."""
    async def failing_ping():
        raise Exception("Database connection failed")

    monkeypatch.setattr("app.core.database.test_connection", failing_ping)

@pytest.fixture
def mock_redis_failure(monkeypatch):
    """Mock Redis connection failure."""
    async def failing_ping():
        raise Exception("Redis connection failed")

    monkeypatch.setattr("app.core.cache.test_connection", failing_ping)
```

**Example Test:**
```python
@pytest.mark.asyncio
async def test_health_check_returns_healthy_when_all_services_up(
    client: AsyncClient,
) -> None:
    """Test health check returns healthy when all services are up."""
    response = await client.get("/api/health")

    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    assert data["database"] == "connected"
    assert data["redis"] == "connected"
    assert "version" in data
```

### Validation

Run tests:
```bash
cd backend
uv run pytest tests/integration/test_health.py -v --cov=app/api/health
```

Expected: 4 tests passing, health.py coverage 80%+

**Estimated Coverage Gain:** +49% for health.py

---

## P1 Task 2: Auth Service Core Tests

**Priority:** P1 (High Value - Critical Module)
**Effort:** 4 hours
**Owner:** Backend Developer
**Issue ID:** TEST-003

### Objective

Achieve 70%+ coverage for auth service by testing core authentication flows.

**Impact:** +35% coverage for auth_service.py (35% → 70%+)

### Current Coverage

```
app/services/auth_service.py: 35% coverage (84 statements, 55 missed)

Uncovered lines:
- Lines 50-66: exchange_code_for_token (GitHub OAuth token exchange)
- Lines 81-90: fetch_github_user (GitHub API user fetch)
- Lines 108-143: create_or_update_user (user creation/update logic)
- Lines 194-199: verify_access_token error paths
- Lines 215-238: refresh_access_token (refresh token flow)
- Lines 255-271: revoke_refresh_token (logout flow)
- Lines 283-286: get_decrypted_github_token
```

### Acceptance Criteria

#### Core OAuth Flow Tests

- [ ] Test: `test_exchange_code_for_token_success`
  - Given: Valid GitHub authorization code
  - When: exchange_code_for_token(code)
  - Then: Returns GitHub access token

- [ ] Test: `test_exchange_code_for_token_invalid_code`
  - Given: Invalid authorization code
  - When: exchange_code_for_token(code)
  - Then: Raises ValueError with error description

- [ ] Test: `test_fetch_github_user_success`
  - Given: Valid GitHub access token
  - When: fetch_github_user(token)
  - Then: Returns user profile dict

- [ ] Test: `test_create_or_update_user_creates_new_user`
  - Given: GitHub user profile for new user
  - When: create_or_update_user(github_user, token)
  - Then: Creates new User in database with encrypted token

- [ ] Test: `test_create_or_update_user_updates_existing_user`
  - Given: GitHub user profile for existing user (by github_id)
  - When: create_or_update_user(github_user, token)
  - Then: Updates existing User record

#### Token Management Tests

- [ ] Test: `test_verify_access_token_invalid_token`
  - Given: Invalid JWT token
  - When: verify_access_token(token)
  - Then: Raises ValueError("Invalid token")

- [ ] Test: `test_verify_access_token_user_not_found`
  - Given: Valid JWT but user deleted from database
  - When: verify_access_token(token)
  - Then: Raises ValueError("User not found")

- [ ] Test: `test_refresh_access_token_success`
  - Given: Valid refresh token in database
  - When: refresh_access_token(token)
  - Then: Returns new access token

- [ ] Test: `test_refresh_access_token_revoked_token`
  - Given: Refresh token that has been revoked
  - When: refresh_access_token(token)
  - Then: Raises ValueError("token has been revoked")

- [ ] Test: `test_refresh_access_token_expired`
  - Given: Expired refresh token
  - When: refresh_access_token(token)
  - Then: Raises ValueError("expired")

- [ ] Test: `test_revoke_refresh_token_success`
  - Given: Valid refresh token
  - When: revoke_refresh_token(token)
  - Then: Token marked as revoked in database

- [ ] Test: `test_get_decrypted_github_token_success`
  - Given: User with encrypted GitHub token
  - When: get_decrypted_github_token(user)
  - Then: Returns decrypted token

### Implementation Details

**File to Create:** `backend/tests/unit/services/test_auth_service.py`

**Required Fixtures:**
```python
@pytest.fixture
async def auth_service(db_session: AsyncSession) -> AuthService:
    """Auth service instance with test database."""
    return AuthService(db_session)

@pytest.fixture
async def test_user_with_token(db_session: AsyncSession) -> User:
    """User with encrypted GitHub token."""
    from app.core.security import encrypt_github_token

    user = User(
        github_id=12345,
        username="testuser",
        email="test@example.com",
        github_access_token=encrypt_github_token("test_token_123"),
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    return user

@pytest.fixture
async def valid_refresh_token(
    auth_service: AuthService,
    test_user: User,
) -> str:
    """Generate valid refresh token for test user."""
    tokens = await auth_service.generate_jwt_tokens(test_user)
    return tokens["refresh_token"]
```

**Example Test:**
```python
@pytest.mark.asyncio
async def test_refresh_access_token_success(
    auth_service: AuthService,
    test_user: User,
    valid_refresh_token: str,
) -> None:
    """Test refreshing access token with valid refresh token."""
    # When: Refresh access token
    result = await auth_service.refresh_access_token(valid_refresh_token)

    # Then: Returns new access token
    assert "access_token" in result
    assert result["token_type"] == "bearer"
    assert result["expires_in"] == 900

    # Verify new token is valid
    from app.core.security import verify_token
    user_id = verify_token(result["access_token"], expected_type="access")
    assert user_id == test_user.id
```

### Validation

Run tests:
```bash
cd backend
uv run pytest tests/unit/services/test_auth_service.py -v --cov=app/services/auth_service
```

Expected: 12 tests passing, auth_service.py coverage 70%+

**Estimated Coverage Gain:** +35% for auth_service.py

---

## P1 Task 3: Workspace Error Scenarios

**Priority:** P1 (Complete Workspace Testing)
**Effort:** 2 hours
**Owner:** Backend Developer
**Issue ID:** TEST-004

### Objective

Achieve 90%+ coverage for workspace_service.py by testing error scenarios and exception handlers.

**Impact:** +9% coverage for workspace_service.py (81% → 90%+)

### Current Coverage

```
app/services/workspace_service.py: 81% coverage (80 statements, 15 missed)

Uncovered lines:
- Lines 71-79: Exception handlers in create_workspace
- Line 110: Not found error path in get_workspace_by_id
- Lines 144-148: Not found warning in update_workspace
- Lines 168-176: Exception handlers in update_workspace
- Lines 205-209: Not found warning in delete_workspace
- Lines 224-232: Exception handlers in delete_workspace
- Line 251: Edge case in check_workspace_member
```

### Acceptance Criteria

#### Error Handling Tests

- [ ] Test: `test_create_workspace_handles_database_error`
  - Given: Database connection fails during workspace creation
  - When: create_workspace() called
  - Then: Logs error and raises exception

- [ ] Test: `test_update_workspace_not_found`
  - Given: Workspace ID that doesn't exist
  - When: update_workspace() called by admin
  - Then: Returns None (or raises appropriate exception)

- [ ] Test: `test_delete_workspace_not_found`
  - Given: Workspace ID that doesn't exist
  - When: delete_workspace() called by admin
  - Then: Logs warning and completes without error

- [ ] Test: `test_check_workspace_member_returns_false_for_non_member`
  - Given: User who is NOT a member of workspace
  - When: check_workspace_member() called
  - Then: Returns False

### Implementation Details

**File:** `backend/tests/unit/services/test_workspace_service.py` (add to existing)

**Required Fixtures:**
```python
@pytest.fixture
def mock_db_error(monkeypatch):
    """Mock database error during commit."""
    async def failing_commit():
        raise Exception("Database connection lost")

    # Will need to mock the specific operation that fails
    return failing_commit
```

**Example Test:**
```python
@pytest.mark.asyncio
async def test_update_workspace_not_found(
    workspace_service: WorkspaceService,
    test_admin_user: User,
) -> None:
    """Test updating non-existent workspace."""
    from uuid import uuid4

    fake_id = uuid4()

    # When: Try to update non-existent workspace
    result = await workspace_service.update_workspace(
        workspace_id=fake_id,
        updates={"name": "New Name"},
        user_id=test_admin_user.id,
    )

    # Then: Returns None or raises appropriate exception
    assert result is None  # or assert raises HTTPException 404
```

### Validation

Run tests:
```bash
cd backend
uv run pytest tests/unit/services/test_workspace_service.py -v --cov=app/services/workspace_service
```

Expected: 11 tests passing (7 existing + 4 new), workspace_service.py coverage 90%+

**Estimated Coverage Gain:** +9% for workspace_service.py

---

## P1 Task 4: Auth API Endpoint Tests

**Priority:** P1 (Complete Auth Module)
**Effort:** 3 hours
**Owner:** Backend Developer
**Issue ID:** TEST-005

### Objective

Achieve 70%+ coverage for auth API endpoints.

**Impact:** +26% coverage for auth.py (44% → 70%+)

### Current Coverage

```
app/api/auth.py: 44% coverage (39 statements, 22 missed)

Uncovered lines:
- Lines 30, 45-52: GitHub callback error handling
- Lines 79-100: Refresh token endpoint
- Lines 126-131: Logout endpoint error handling
- Lines 159-162: GitHub login initiation endpoint
```

### Acceptance Criteria

#### Refresh Token Tests

- [ ] Test: `test_refresh_token_success`
  - Given: Valid refresh token
  - When: POST /auth/refresh with {"refresh_token": "..."}
  - Then: 200 with new access token

- [ ] Test: `test_refresh_token_invalid`
  - Given: Invalid refresh token
  - When: POST /auth/refresh
  - Then: 401 Unauthorized

- [ ] Test: `test_refresh_token_revoked`
  - Given: Revoked refresh token
  - When: POST /auth/refresh
  - Then: 401 with error about revoked token

#### Logout Tests

- [ ] Test: `test_logout_success`
  - Given: Valid refresh token
  - When: POST /auth/logout with {"refresh_token": "..."}
  - Then: 200, token revoked in database

- [ ] Test: `test_logout_already_revoked`
  - Given: Already revoked token
  - When: POST /auth/logout
  - Then: 401 (token not found or already revoked)

#### GitHub OAuth Initiation

- [ ] Test: `test_github_login_redirect`
  - Given: User initiating GitHub OAuth
  - When: GET /auth/github
  - Then: 302 redirect to GitHub with correct client_id and scope

### Implementation Details

**File:** `backend/tests/integration/test_auth.py` (add to existing)

**Example Test:**
```python
@pytest.mark.asyncio
async def test_refresh_token_success(
    client: AsyncClient,
    db_session: AsyncSession,
) -> None:
    """Test refreshing access token with valid refresh token."""
    # Setup: Create user and generate tokens
    from app.services.auth_service import AuthService

    user = User(
        github_id=99999,
        username="refreshuser",
        email="refresh@example.com",
    )
    db_session.add(user)
    await db_session.commit()

    auth_service = AuthService(db_session)
    tokens = await auth_service.generate_jwt_tokens(user)
    refresh_token = tokens["refresh_token"]

    # When: Request new access token
    response = await client.post(
        "/auth/refresh",
        json={"refresh_token": refresh_token},
    )

    # Then: Returns new access token
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"
    assert data["expires_in"] == 900
```

### Validation

Run tests:
```bash
cd backend
uv run pytest tests/integration/test_auth.py -v --cov=app/api/auth
```

Expected: 11 tests passing (5 existing + 6 new), auth.py coverage 70%+

**Estimated Coverage Gain:** +26% for auth.py

---

## P1 Task 5: Dependencies Module Tests

**Priority:** P1 (Complete Auth Flow)
**Effort:** 1 hour
**Owner:** Backend Developer
**Issue ID:** TEST-006

### Objective

Achieve 70%+ coverage for dependencies module by testing error paths.

**Impact:** +22% coverage for dependencies.py (48% → 70%+)

### Current Coverage

```
app/api/dependencies.py: 48% coverage (44 statements, 23 missed)

Uncovered lines:
- Lines 49-75: get_current_user error handling (expired token, user not found)
- Lines 99-107: get_current_user_optional
- Lines 126-129: check_workspace_admin
- Lines 153-154: check_workspace_member error path
```

### Acceptance Criteria

- [ ] Test: `test_get_current_user_expired_token`
  - Given: Expired JWT token
  - When: Dependency invoked
  - Then: Raises HTTPException 401 with "token_expired" type

- [ ] Test: `test_get_current_user_user_deleted`
  - Given: Valid JWT but user deleted from database
  - When: Dependency invoked
  - Then: Raises HTTPException 401 with "user_not_found" type

- [ ] Test: `test_get_current_user_optional_no_token`
  - Given: No authentication header
  - When: Dependency invoked
  - Then: Returns None (no exception)

- [ ] Test: `test_get_current_user_optional_invalid_token`
  - Given: Invalid token
  - When: Dependency invoked
  - Then: Returns None (no exception)

- [ ] Test: `test_check_workspace_admin_not_admin`
  - Given: User is MEMBER (not ADMIN) of workspace
  - When: Dependency invoked
  - Then: Raises HTTPException 403

### Implementation Details

**File:** `backend/tests/integration/test_dependencies.py` (create new)

**Example Test:**
```python
@pytest.mark.asyncio
async def test_get_current_user_expired_token(
    client: AsyncClient,
    db_session: AsyncSession,
) -> None:
    """Test that expired tokens return 401 with token_expired type."""
    from app.core.security import create_access_token
    from datetime import datetime, timezone
    from uuid import uuid4

    # Create expired token (exp in the past)
    user_id = uuid4()
    expired_token = create_access_token(
        user_id=user_id,
        expires_delta=timedelta(seconds=-3600)  # 1 hour ago
    )

    # When: Request with expired token
    response = await client.get(
        "/api/me",
        headers={"Authorization": f"Bearer {expired_token}"},
    )

    # Then: Returns 401 with token_expired type
    assert response.status_code == 401
    data = response.json()
    assert data["detail"]["type"] == "token_expired"
```

### Validation

Run tests:
```bash
cd backend
uv run pytest tests/integration/test_dependencies.py -v --cov=app/api/dependencies
```

Expected: 5 tests passing, dependencies.py coverage 70%+

**Estimated Coverage Gain:** +22% for dependencies.py

---

## Task Summary & Sequencing

### Recommended Order

1. **P1-1: Health Endpoint Tests** (2h) - Easy wins, high coverage gain
2. **P1-3: Workspace Error Scenarios** (2h) - Complete workspace testing
3. **P1-2: Auth Service Core Tests** (4h) - Critical module, high value
4. **P1-4: Auth API Endpoint Tests** (3h) - Complete auth module
5. **P1-5: Dependencies Module Tests** (1h) - Final auth flow coverage

**Total:** 12 hours

### Expected Coverage After P1 Tasks

| Module | Before | After | Gain |
|--------|--------|-------|------|
| health.py | 31% | 80%+ | +49% |
| workspace_service.py | 81% | 90%+ | +9% |
| auth_service.py | 35% | 70%+ | +35% |
| auth.py | 44% | 70%+ | +26% |
| dependencies.py | 48% | 70%+ | +22% |

**Overall Project Coverage:**
- Before: 66%
- After: **~78-80%** ✅

---

## Validation Commands

### Run All P1 Tests
```bash
cd backend

# Run all new tests
uv run pytest \
  tests/integration/test_health.py \
  tests/unit/services/test_auth_service.py \
  tests/unit/services/test_workspace_service.py \
  tests/integration/test_auth.py \
  tests/integration/test_dependencies.py \
  -v

# Check overall coverage
uv run pytest tests/ --cov=app --cov-report=term-missing
```

### Expected Results
- Total tests: ~55 (29 existing + ~26 new)
- Pass rate: 100%
- Overall coverage: 78-80%

---

## Gate Decision Criteria

### PASS Criteria

After completing P1 tasks:
- [ ] Overall project coverage ≥ 78%
- [ ] All workspace tests passing (29/29)
- [ ] All auth tests passing (~18/18)
- [ ] All health tests passing (4/4)
- [ ] No critical uncovered paths in core modules
- [ ] All tests documented with Given-When-Then structure

### Acceptance

Once P1 tasks are complete:
- ✅ Story 2.1 quality gate: **PASS**
- ✅ Ready for production deployment
- ✅ Meets DoD coverage requirements

---

## Optional: P2 Tasks for 85%+ Coverage

If additional coverage desired:

**P2-1: Model Tests** (3h)
- Test model validations
- Test model relationships
- Coverage gain: +5-10%

**P2-2: Middleware Tests** (2h)
- Test correlation ID middleware edge cases
- Test CORS middleware
- Coverage gain: +3-5%

**P2-3: Integration Error Scenarios** (2h)
- Test database transaction rollbacks
- Test concurrent modification handling
- Coverage gain: +2-4%

**Total P2 Effort:** 7 hours
**Expected Coverage:** 85-90%

---

## Notes

1. **Mocking Strategy:** Use pytest monkeypatch for database/external service failures
2. **Test Isolation:** All tests should use transaction rollback for cleanup
3. **Documentation:** All tests must have clear Given-When-Then docstrings
4. **Error Messages:** Verify error messages are user-friendly and actionable
5. **Security:** Test error paths don't leak sensitive information

---

**Document Status:** Ready for Implementation
**Created:** 2025-10-25
**Last Updated:** 2025-10-25
